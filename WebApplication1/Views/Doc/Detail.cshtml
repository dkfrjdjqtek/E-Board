@* 2025.12.05 Changed: 승인 서명 스탬프 compCd UserId 기반 경로 적용 승인자 캡션 공통 함수 사용 상세 타이틀을 "작성자님의 문서명"으로 표시 상단 문서 메타 영역 숨김 댓글 파일 업로드 UI 비활성화 및 null 요소 이벤트 바인딩 오류 제거 *@
@* 2025.12.03 Changed: 결재 정보 Role 컬럼 제거 이름 표시 및 상태 다국어 매핑 문서 확인 로그 최초 1회만 표시 *@
@* 2025.12.01 Changed: Detail 레이아웃을 Compose 와 동일 scroll host(#doc-scroll) 방식으로 통일
   - html/body 전역 스크롤을 숨기고 #doc-scroll 고정 컨테이너 한 곳만 세로/가로 스크롤 담당
   - 기존 .container-xxl.doc-detail-root 를 #doc-scroll 안으로 래핑하여 Compose 와 동일한 위치/스크롤 UX 유지
   - @media print 에서 #doc-scroll 위치/스크롤 제약을 해제하여 인쇄 시 문서만 자연스럽게 출력되도록 보정 *@
@* 2025.11.07 Changed:
    - DOC 상세 화면을 세로 단일 컬럼 구조로 재배치
    - Compose와 동일한 엑셀 기반 프리뷰 렌더링 로직 적용 (read-only)
    - 타이틀/프리뷰/댓글/조회 로그/승인 정보·버튼 순서 정렬
    - [2025.11.10] 인쇄 시 순수 문서 프리뷰(#xhost)만 출력하도록 @media print 정리
    - [2025.11.10] 하단 고정 승인/보류/반려 버튼 추가 (1/2 : 1/4 : 1/4)
*@
@using System.Text.Json
@model WebApplication1.Models.DocTLViewModel
@inject Microsoft.Extensions.Localization.IStringLocalizer<SharedResource> S

@{
    ViewData["Title"] = S["DOC_Title_Detail"];

    // ★ docId를 실제 DocumentComments.DocId 와 동일하게 맞춰서 가져오도록 정리
    var docId =
        (string?)ViewBag.DocId
        ?? (string?)ViewBag.DocumentId
        ?? (Context?.Request?.Query["id"].ToString() ?? string.Empty);

    var templateCode = (string?)ViewBag.TemplateCode ?? string.Empty;
    var templateTitle = (string?)ViewBag.TemplateTitle ?? string.Empty;
    var status = (string?)ViewBag.Status ?? "Draft";
    var compCd = (string?)ViewBag.CompCd ?? string.Empty;
    var creatorName =
        (string?)ViewBag.CreatorName
        ?? (string?)ViewBag.OwnerName
        ?? (string?)ViewBag.CreatedByName
        ?? string.Empty;

    // ★ 직책/부서가 포함된 전체 문자열에서 마지막 토큰만 이름으로 사용
    var creatorDisplayName = creatorName;
    if (!string.IsNullOrWhiteSpace(creatorDisplayName))
    {
        var parts = creatorDisplayName.Split(' ', StringSplitOptions.RemoveEmptyEntries);
        if (parts.Length > 0)
        {
            creatorDisplayName = parts[^1];
        }
    }

    var docTitle =
        !string.IsNullOrEmpty(templateTitle)
            ? templateTitle
            : ((string?)ViewBag.DocTitle ?? string.Empty);

    string NormalizeJson(object value, string emptyJson = "{}")
    {
        if (value == null) return emptyJson;

        if (value is string s)
        {
            s = s.Trim();
            if (string.IsNullOrEmpty(s)) return emptyJson;

            if ((s.StartsWith("{") && s.EndsWith("}")) ||
                (s.StartsWith("[") && s.EndsWith("]")))
                return s;

            return s;
        }

        try { return JsonSerializer.Serialize(value); }
        catch { return emptyJson; }
    }

    string NormalizeJsonArray(object value) => NormalizeJson(value, "[]");

    var descJson = NormalizeJson(ViewBag.DescriptorJson);
    var previewJson = NormalizeJson(ViewBag.PreviewJson);
    var inputsJson = NormalizeJson(ViewBag.InputsJson);
    var approvalsJson = NormalizeJsonArray(ViewBag.ApprovalsJson);
    var viewLogsJson = NormalizeJsonArray(ViewBag.ViewLogsJson);
    var approvalCellsJson = NormalizeJsonArray(ViewBag.ApprovalCellsJson);

    var canRecall = (bool?)ViewBag.CanBackToNew ?? false;
    var canPrint = (bool?)ViewBag.CanPrint ?? true;
    var canExport = (bool?)ViewBag.CanExportPdf ?? true;
    var canApprove = (bool?)ViewBag.CanApprove ?? false;
    var canHold = (bool?)ViewBag.CanHold ?? false;
    var canReject = (bool?)ViewBag.CanReject ?? false;

}

<style>
    /* ===== Compose 와 동일: 전역 스크롤은 막고, #doc-scroll 하나만 스크롤 허용 ===== */
    html,
    body {
        height: 100%;
        overflow: hidden !important;
        background: #fff;
        margin: 0;
    }

    /* Board/Compose 와 같은 CSS 변수 기반 고정 위치 스크롤 컨테이너 */
    #doc-scroll {
        position: fixed;
        top: var(--header-h, 56px) !important;
        right: 0 !important;
        bottom: var(--footer-h, 32px) !important;
        left: var(--sidebar-w, 270px) !important;
        box-sizing: border-box;
        padding: 16px 24px;
        background: #fff;
        overflow-y: auto; /* 세로 스크롤 */
        overflow-x: auto; /* 가로 스크롤 (문서 폭이 넓을 때) */
        overscroll-behavior: contain;
    }

    :root {
        --vscroll-w: 0px;
        --eb-group-bg: rgb(240 248 255 / 55%);
        --eb-group-bg-hover: rgb(240 248 255 / 55%);
        --eb-ring-border: #8CB8FF;
        --eb-ring-glow: rgba(140,184,255,.35);
        --eb-ring-w: 2px;
        --eb-ring-pad: 2px;
        --eb-ring-glow-w: 4px;
    }

    .doc-detail-root {
        padding-top: 1.25rem;
        padding-bottom: 2rem;
    }

    .doc-detail-header {
        display: flex;
        flex-wrap: wrap;
        align-items: center;
        gap: .5rem 1rem;
        margin-bottom: 1rem;
    }

    .doc-detail-title {
        font-size: 1.35rem;
        font-weight: 600;
    }

    .doc-detail-meta {
        display: flex;
        flex-wrap: wrap;
        gap: .4rem .9rem;
        font-size: .85rem;
        color: #6b7280;
    }

    .doc-detail-actions {
        margin-left: 0;
        display: flex;
        flex-wrap: wrap;
        gap: .25rem;
    }

    .badge.status-Draft {
        background: #e2e8f0;
        color: #111827;
    }

    .badge.status-Submitted {
        background: #c7d2fe;
        color: #1e1b4b;
    }

    .badge.status-InProgress {
        background: #fde68a;
        color: #78350f;
    }

    .badge.status-Approved {
        background: #bbf7d0;
        color: #065f46;
    }

    .badge.status-Rejected {
        background: #fecaca;
        color: #7f1d1d;
    }

    .doc-section {
        background: #ffffff;
        border: 1px solid #e5e7eb;
        border-radius: .375rem;
        padding: .75rem .875rem;
        margin-bottom: .75rem;
    }

    .doc-section-title {
        font-size: .95rem;
        font-weight: 600;
        margin-bottom: .35rem;
        display: flex;
        align-items: center;
        gap: .4rem;
    }

    .doc-section-sub {
        font-size: .78rem;
        color: #9ca3af;
        margin-left: .15rem;
    }

    /* ===== 프리뷰 ===== */

    .doc-preview-full {
        padding: 0;
        margin: 0 0 1rem 0;
        border: none;
        background: transparent;
    }

    #xhost {
        display: block;
        width: auto;
        max-width: none;
        overflow: hidden;
        position: relative;
    }

    .xlfb {
        border-collapse: collapse;
        table-layout: fixed;
        position: relative;
        background: #ffffff;
    }

        .xlfb td,
        .xlfb th {
            box-sizing: border-box;
            position: relative;
        }

        .xlfb thead,
        .xlfb tbody th {
            display: none;
        }

        .xlfb td {
            padding: 0;
            vertical-align: middle;
            overflow: hidden;
            word-break: break-word;
            white-space: pre-wrap;
        }

            .xlfb td.ta-left .cellc,
            .xlfb td.eb-editable .cellc,
            .xlfb td.eb-group .cellc,
            .xlfb td[data-key] .cellc {
                padding-left: 4px;
                padding-right: 2px;
                box-sizing: border-box;
            }
    .ta-left {
        text-align: left;
    }

    .ta-center {
        text-align: center;
    }

    .ta-right {
        text-align: right;
    }

    .va-top {
        vertical-align: top;
    }

    .va-middle {
        vertical-align: middle;
    }

    .va-bottom {
        vertical-align: bottom;
    }

    /* Compose 와 동일: WrapText 셀에만 .wrap 이 걸리고 pre-line 으로 개행 + 자동 줄바꿈 */
    .wrap {
        white-space: pre-line;
    }


    /* ===== 댓글/로그/승인 ===== */

    .doc-comments-list {
        max-height: 800px;
        overflow-y: auto;
        padding-right: 2px;
        display: flex;
        flex-direction: column;
        gap: .5rem;
        font-size: .86rem;
        margin-left: 0;
        padding-left: 0;
    }

    .doc-comment-item {
        border-bottom: 1px solid #f3f4f6;
        padding-bottom: .35rem;
        margin-left: 0;
    }

    .doc-comment-meta {
        display: flex;
        flex-wrap: wrap;
        gap: .5rem;
        font-size: .78rem;
        color: #9ca3af;
    }

    .doc-comment-body {
        margin-top: .15rem;
        white-space: pre-wrap;
        word-break: break-word;
    }

    .doc-comment-files {
        margin-top: .15rem;
        font-size: .78rem;
    }

    .doc-comment-form textarea {
        width: 100%;
        resize: vertical;
        min-height: 80px;
    }

    #cmt-file-list li {
        display: flex;
        align-items: center;
        gap: .5rem;
    }

    #cmt-file-list button[data-remove] {
        padding: .1rem .4rem;
    }

    .doc-viewlog-list {
        max-height: 160px;
        overflow-y: auto;
        font-size: .8rem;
        white-space: nowrap;
    }

    .doc-approvals-table {
        width: 100%;
        font-size: .8rem;
    }

        .doc-approvals-table th,
        .doc-approvals-table td {
            padding: .25rem .4rem;
            border: 1px solid #e5e7eb;
        }

    .doc-approvals-actions {
        display: flex;
        flex-wrap: wrap;
        gap: .5rem;
        justify-content: space-between;
        margin-top: .4rem;
        width: 100%;
    }

        .doc-approvals-actions button {
            height: 2.5rem;
            font-size: .92rem;
            font-weight: 600;
        }

    /* ===== 하단 고정 버튼바 ===== */

    .doc-bottom-actions {
        position: sticky;
        bottom: 0;
        z-index: 50;
        display: flex;
        gap: .5rem;
        padding: .5rem .75rem .75rem;
        margin-top: .5rem;
        background: #ffffff;
        border-top: 1px solid #e5e7eb;
    }

        .doc-bottom-actions button {
            height: 2.75rem;
            font-size: .95rem;
            font-weight: 600;
        }

    /* ★ 비율: 승인 1/2, 보류/반려 각 1/4 */
    .doc-approvals-actions .btn-approve {
        flex: 2 1 0;
    }

    .doc-approvals-actions .btn-hold,
    .doc-approvals-actions .btn-reject {
        flex: 1 1 0;
    }

    .doc-approval-cell {
        position: relative;
        overflow: hidden;
    }

    .doc-approval-cell-img {
        display: block;
        width: 100%;
        height: 100%;
        object-fit: contain;
    }

    .doc-approval-caption {
        position: absolute;
        bottom: 2px;
        left: 0;
        right: 0;
        text-align: center;
        font-size: 0.65rem;
        line-height: 1.05;
        pointer-events: none;
        background: rgba(255,255,255,0.6); /* 필요 시 제거 가능 */
    }

        /* ▼ Detail 의 #xhost 에 맞게 cell 컨테이너 성격만 유지 (폰트/크기는 공용 CSS 기준) */
    .cellc {
        max-height: 100%;
        overflow: hidden;
        display: block;
    }

    /* ★ 매핑/입력 셀(td.eb-editable)만 폰트 강제 (엑셀 서식은 유지하되 폰트만 예외) */
    .xlfb td.eb-editable .cellc,
    .xlfb td[data-key] .cellc,
    .xlfb td.eb-group .cellc {
        font-family: 'Malgun Gothic', '맑은 고딕', 'Apple SD Gothic Neo', 'Segoe UI', Arial, system-ui, sans-serif !important;
        font-size: 14.6667px !important;
        letter-spacing: 0px !important;
        word-spacing: 0px !important;
    }

    /* ================== 문서 출력 전용 ================== */
    @@media print {
        @@page {
            size: A4 portrait;
            margin: 0;
        }

        html,
        body {
            margin: 0 !important;
            padding: 0 !important;
            background: #fff !important;
        }
            /* 기본적으로 다 숨김 */
            body * {
                visibility: hidden !important;
            }

        .doc-preview-full,
        .doc-preview-full * {
            visibility: visible !important;
        }

        .doc-detail-header,
        .doc-section,
        #detail-alert,
        .doc-bottom-actions {
            display: none !important;
        }
        /* 프린트용 래퍼만 보이게 */
        #print-xhost-wrapper,
        #print-xhost-wrapper * {
            visibility: visible !important;
        }

        #print-xhost-wrapper {
            margin: 0 !important;
            padding: 0 !important;
            width: 100% !important;
            max-width: none !important;
            background: #fff !important;
        }
            /* 실제 문서 영역을 페이지 가로 꽉 채우기 */
            #print-xhost-wrapper #xhost {
                margin: 0 !important;
                padding: 0 !important;
                border: none !important;
                width: 100% !important;
                max-width: none !important;
                background: #fff !important;
                overflow: visible !important;
            }

                #print-xhost-wrapper #xhost .xlfb {
                    display: table !important;
                    table-layout: fixed !important;
                    border-collapse: collapse !important;
                    width: 100% !important;
                    margin: 0 !important;
                    padding: 0 !important;
                    background: #fff !important;
                }

                    #print-xhost-wrapper #xhost .xlfb tr {
                        display: table-row !important;
                    }

                    #print-xhost-wrapper #xhost .xlfb td,
                    #print-xhost-wrapper #xhost .xlfb th {
                        display: table-cell !important;
                        vertical-align: middle !important;
                    }

                    #print-xhost-wrapper #xhost .xlfb,
                    #print-xhost-wrapper #xhost .xlfb * {
                        max-height: none !important;
                        overflow: visible !important;
                    }

        #xhost {
            display: block !important;
            position: static !important;
            margin: 0 !important;
            padding: 0 !important;
            width: 100% !important;
            max-width: 100% !important;
            overflow: visible !important;
            background: #fff !important;
        }

            #xhost .xlfb,
            #xhost .xlfb tr,
            #xhost .xlfb td,
            #xhost .xlfb th {
                page-break-inside: auto !important;
                break-inside: auto !important;
            }
    }

</style>

<div id="doc-scroll">

    <div class="doc-detail-root"
         data-doc-id="@docId"
         data-doc-title="@docTitle"
         data-creator-name="@creatorName"
         data-status="@status"
         data-created-at="@(
        (ViewBag.CreatedAtText as string)
        ?? (ViewBag.CreatedAt != null ? Convert.ToString(ViewBag.CreatedAt) : null)
        ?? (ViewBag.UpdatedAtText as string)
        ?? (ViewBag.UpdatedAt != null ? Convert.ToString(ViewBag.UpdatedAt) : null)
        ?? string.Empty
     )"
         data-recalled-at="@(
        (ViewBag.RecalledAtText as string)
        ?? (ViewBag.RecalledAt != null ? Convert.ToString(ViewBag.RecalledAt) : null)
        ?? (ViewBag.UpdatedAtText as string)
        ?? (ViewBag.UpdatedAt != null ? Convert.ToString(ViewBag.UpdatedAt) : null)
        ?? string.Empty
     )"
         style="padding-left: 16px; padding-right: 24px; max-width: 100%;">

        <!-- 상단 타이틀 + 메타 + 액션 -->
        <header class="doc-detail-header">
            <div>
                <div class="doc-detail-title">
                    @if (!string.IsNullOrEmpty(creatorDisplayName) && !string.IsNullOrEmpty(docTitle))
                    {
                        @($"{creatorDisplayName}님의 {docTitle}")
                    }
                    else
                    {
                        @S["DOC_Title_Detail"]
                    }
                </div>

                @* 2025.12.05 Changed: 문서 메타(DocId, 템플릿, 상태)는 사용자에게 노출하지 않도록 일시 숨김 *@
                @*
                <div class="doc-detail-meta">
                <span><strong>@S["DOC_Label_DocId"]</strong> : <code>@docId</code></span>
                <span>
                <strong>@S["_CM_Label_Template"]</strong> :
                <code>@templateCode</code>
                <span class="ms-1">@templateTitle</span>
                </span>
                <span class="badge status-@status">@S[$"DOC_Status_{status}"]</span>
                </div>
                *@

                <!-- 버튼들을 왼쪽(타이틀 아래)으로 배치 -->
                <div class="doc-detail-actions mt-1">
                    @if (canRecall)
                    {
                        <button type="button"
                                class="btn btn-sm btn-dark me-1"
                                id="btnRecall"
                                data-recall>
                            @S["DOC_Btn_Recall"]
                        </button>
                    }

                    @if (canPrint)
                    {
                        <button type="button"
                                class="btn btn-sm btn-outline-primary"
                                id="btnPrint"
                                title="@S["DOC_Btn_Print"]">
                            <i class="bi bi-printer"></i>
                        </button>
                    }
                    @if (canExport)
                    {
                        <button type="button"
                                class="btn btn-sm btn-outline-primary"
                                id="btnExport"
                                title="@S["DOC_Btn_Export"]">
                            <i class="bi bi-file-earmark-pdf"></i>
                        </button>
                    }
                </div>
            </div>
        </header>

        <div id="detail-alert" class="mb-2" aria-live="polite"></div>

        <!-- 1. 문서 프리뷰 -->
        <section class="doc-preview-full" aria-label="Document preview">
            <script type="application/json" id="DescriptorJson">@Html.Raw(descJson)</script>
            <script type="application/json" id="PreviewJson">@Html.Raw(previewJson)</script>
            <script type="application/json" id="InputsJson">@Html.Raw(inputsJson)</script>
            <div id="xhost"></div>
        </section>

        <!-- 2. 코멘트 리스트 -->
        <section class="doc-section" aria-labelledby="doc-comments-list-title">
            <div id="doc-comments-list-title" class="doc-section-title">
                @S["_CM_Comment_Label"]
                <span id="cmt-count" class="doc-section-sub"></span>
            </div>
            <div id="cmt-alert" class="mb-1" aria-live="polite"></div>
            <div id="cmt-list" class="doc-comments-list"></div>
        </section>

        <!-- 3. 코멘트 입력 -->
        <section class="doc-section" aria-labelledby="doc-comment-form-title">
            <div id="doc-comment-form-title" class="doc-section-title">
                @S["DOC_Label_AddComment"]
            </div>
            <div class="doc-comment-form">
                <textarea id="cmt-body"
                          class="form-control"
                          rows="3"
                          placeholder="@S["DOC_Placeholder_Comment"]"></textarea>

                @* 2025.12.05 Changed: 댓글 파일 업로드 기능은 일단 비활성화 (사용자에게 노출하지 않음)
                <div class="mt-2">
                <input id="cmt-file" type="file" class="form-control form-control-sm" multiple />
                <div class="small text-muted mt-1">@S["DOC_File_Help_UploadTypes"]</div>
                <ul id="cmt-file-list" class="mt-2 mb-0 small"></ul>
                </div>
                *@

                <div class="d-flex gap-2 mt-2 justify-content-end">
                    <button id="cmt-submit" type="button" class="btn btn-sm btn-primary">
                        @S["DOC_Btn_CommentPost"]
                    </button>
                </div>
            </div>
        </section>

        <!-- 4. 조회 로그 -->
        <section class="doc-section" aria-labelledby="doc-viewlog-title">
            <div id="doc-viewlog-title" class="doc-section-title">
                @S["DOC_Title_ViewLog"]
            </div>
            <div id="viewlog-list" class="doc-viewlog-list"></div>
        </section>

        <!-- 5. 승인 정보 + 상단 작은 버튼 -->
        <section class="doc-section" aria-labelledby="doc-approvals-title">
            <div id="doc-approvals-title" class="doc-section-title">
                @S["DOC_Label_Approvals"]
                @* <span class="doc-section-sub">@S["DOC_Help_ApprovalsReadonly"]</span> *@
            </div>

            <table class="doc-approvals-table">
                <thead>
                    <tr>
                        <th style="width:40%;">@S["DOC_Col_ApproverValue"]</th>
                        <th style="width:20%;">@S["DOC_Col_Status"]</th>
                        <th style="width:25%;">@S["DOC_Col_ApprovalTime"]</th>
                    </tr>
                </thead>
                <tbody id="tbody-approvals"></tbody>
            </table>

            <div class="doc-approvals-actions">
                <button type="button"
                        class="btn btn-sm btn-success btn-approve"
                        data-approve
                @(canApprove ? "" : "disabled")>
                    @S["DOC_Btn_Approve"]
                </button>
                <button type="button"
                        class="btn btn-sm btn-warning btn-hold"
                        data-hold
                @(canHold ? "" : "disabled")>
                    @S["DOC_Btn_Hold"]
                </button>
                <button type="button"
                        class="btn btn-sm btn-danger btn-reject"
                        data-reject
                @(canReject ? "" : "disabled")>
                    @S["DOC_Btn_Reject"]
                </button>
            </div>
        </section>

        @* 하단 큰 버튼바는 현재 주석 처리 상태 *@
    </div>
</div>

@* 2025.12.02 Changed: Detail 미리보기 테이블에 승인 서명 이미지 오버레이 및 결재 셀 동적 매핑 적용 *@
@section Scripts {
    <script src="~/js/eb.csrf.js"></script>
    <script>
        // ===== 승인/결재 공통 데이터 + 셀 매핑 =====

        window.approvalsData = (function () {
            try {
                var j = @Html.Raw(approvalsJson);
                return Array.isArray(j) ? j : [];
            } catch { return []; }
        })();

        console.log('DBG approvalsData', window.approvalsData);
        console.log('DBG APPROVAL_SIGN_CELL_MAP(before)', window.APPROVAL_SIGN_CELL_MAP);

        window.APPROVAL_SIGN_CELL_MAP = (function () {
            try {
                var rows = @Html.Raw(approvalCellsJson);
                var map = {};
                if (Array.isArray(rows)) {
                    rows.forEach(function (r) {
                        var step = r.step || r.Step || r.slot || r.Slot;
                        var a1 = r.a1 || r.A1 || r.cellA1 || r.CellA1;
                        if (!step || !a1) return;
                        map[step] = a1;
                    });
                }
                return map;
            } catch {
                return {};
            }
        })();

        // ================== 공통 유틸 ==================
        function decodeHtmlEntities(str) {
            if (str == null) return '';
            let s = String(str);
            s = s.replace(/&#x([0-9a-fA-F]+);/g, (_, h) => String.fromCodePoint(parseInt(h, 16)));
            s = s.replace(/&#(\d+);/g, (_, d) => String.fromCodePoint(parseInt(d, 10)));
            s = s.replace(/&lt;/g, '<').replace(/&gt;/g, '>').replace(/&amp;/g, '&')
                .replace(/&quot;/g, '"').replace(/&apos;/g, "'");
            return s;
        }

        // 2025.12.04 Changed: Reply 폼에서 사용하는 DOC_Btn_CommentPost / Edit / Delete 등 리소스 포함
        window.__RESX = {
            DOC_Err_PreviewFailed: "@S["DOC_Err_PreviewFailed"]",
            DOC_Msg_PreviewFallback: "@S["DOC_Msg_PreviewFallback"]",
            DOC_Msg_NoComments: "@S["DOC_Msg_NoComments"]",
            DOC_Msg_NoViewLogs: "@S["DOC_Msg_NoViewLogs"]",
            DOC_Msg_NoApprovals: "@S["DOC_Msg_NoApprovals"]",
            DOC_Msg_CommentCreated: "@S["DOC_Msg_CommentCreated"]",
            DOC_Msg_CommentDeleted: "@S["DOC_Msg_CommentDeleted"]",
            DOC_Msg_CommentUpdated: "@S["DOC_Msg_CommentUpdated"]",
            DOC_Err_SaveFailed: "@S["DOC_Err_SaveFailed"]",
            DOC_Err_DeleteFailed: "@S["DOC_Err_DeleteFailed"]",
            DOC_Err_LoadFailed: "@S["DOC_Err_LoadFailed"]",
            DOC_Err_DocumentNotFound: "@S["DOC_Err_DocumentNotFound"]",
            DOC_Err_RequestFailed: "@S["DOC_Err_RequestFailed"]",
            DOC_Msg_Approve_Success: "@S["DOC_Msg_Approve_Success"]",
            DOC_Val_Required: "@S["DOC_Val_Required"]",
            DOC_Cmt_Count: "@S["DOC_Cmt_Count"]",
            DOC_Btn_Reply: "@S["DOC_Btn_Reply"]",
            _CM_Delete: "@S["_CM_Delete"]",
            _CM_Edit: "@S["_CM_Edit"]",
            DOC_Btn_Save: "@S["DOC_Btn_Save"]",
            DOC_Btn_Cancel: "@S["DOC_Btn_Cancel"]",
            DOC_Btn_ReplyPost: "@S["DOC_Btn_ReplyPost"]",
            DOC_Placeholder_Reply: "@S["DOC_Placeholder_Reply"]",
            DOC_StatusShort_Pending: "@S["DOC_StatusShort_Pending"]",
            DOC_Status_Pending: "@S["DOC_Status_Pending"]",
            DOC_Status_Approved: "@S["DOC_Status_Approved"]",
            DOC_Status_Rejected: "@S["DOC_Status_Rejected"]",
            DOC_Status_OnHold: "@S["DOC_Status_OnHold"]",
            DOC_Status_Recalled: "@S["DOC_Status_Recalled"]",
            DOC_Confirm_DeleteComment: "@S["DOC_Confirm_DeleteComment"]",
            DOC_Msg_Recall_Success: "@S["DOC_Msg_Recall_Success"]",
            // ★ 작성 상태 텍스트(리소스가 없으면 '작성'으로 대체)
            DOC_Status_Created: "@S["DOC_Status_Created"]"
        };

        const T = (m) => {
            if (m == null) return '';
            if (Array.isArray(m)) return m.map(T).join('\n');
            const s = String(m);
            const mapped = (window.__RESX && Object.prototype.hasOwnProperty.call(window.__RESX, s))
                ? window.__RESX[s] : s;
            return decodeHtmlEntities(mapped);
        };

        // ★ 상태 문자열 → 다국어 리소스 키 매핑
        function mapStatusKey(raw) {
            const s = String(raw || '').toUpperCase();
            if (!s) return '';
            if (s.startsWith('PENDING')) return 'DOC_Status_Pending';
            if (s === 'APPROVED' || s === 'APPROVE') return 'DOC_Status_Approved';
            if (s === 'REJECTED' || s === 'REJECT') return 'DOC_Status_Rejected';
            if (s.startsWith('ONHOLD') || s === 'HOLD') return 'DOC_Status_OnHold';
            if (s === 'RECALLED') return 'DOC_Status_Recalled';
            return raw;
        }

        function extractPersonName(full) {
            if (!full) return '';
            const s = String(full).trim();

            if (s.includes('@@')) {
                return '';
            }

            let parts = s.split(/\s+/).filter(Boolean);
            if (!parts.length) return '';

            parts = parts.map(p => p.replace(/님$/, ''));

            const hasHangul = t => /[가-힣]/.test(t);

            for (let i = parts.length - 1; i >= 0; i--) {
                if (hasHangul(parts[i])) return parts[i];
            }

            return parts[parts.length - 1];
        }

        function readJsonFromScript(id, fallback) {
            try {
                const el = document.getElementById(id);
                if (!el) return fallback;
                const raw = el.textContent || '';
                if (!raw.trim()) return fallback;
                let v = JSON.parse(raw);
                if (typeof v === 'string') {
                    try { v = JSON.parse(v); } catch { }
                }
                return (v && typeof v === 'object') ? v : fallback;
            } catch { return fallback; }
        }

        function a1ToRowCol(a1) {
            if (!a1) return null;
            const m = /^([A-Z]+)(\d+)$/.exec(String(a1).toUpperCase());
            if (!m) return null;
            const letters = m[1];
            const row = parseInt(m[2], 10);
            if (!row || !isFinite(row)) return null;
            let col = 0;
            for (let i = 0; i < letters.length; i++) {
                col = col * 26 + (letters.charCodeAt(i) - 64);
            }
            return { row, col };
        }

        // ★ 승인자 표시 텍스트 공통 함수 (서명 캡션 + 결재 정보 표에 모두 사용)
        function getApprovalDisplayName(a) {
            if (!a) return '';

            var v =
                a.approverDisplayText || a.ApproverDisplayText ||
                a.approverName || a.ApproverName ||
                a.actorName || a.ActorName ||
                a.userName || a.UserName ||
                a.approverValue || a.ApproverValue ||
                a.value || a.Value || '';

            return String(v || '').trim();
        }

        // ================== 프리뷰 렌더링 ==================
        (function () {
            const preview = readJsonFromScript('PreviewJson', {});
            const descriptor = readJsonFromScript('DescriptorJson', {});
            const inputs = readJsonFromScript('InputsJson', {});

            window.descriptor = descriptor;

            // ★ Detail에서 "매핑/입력 셀" A1 집합 구성 (InputsJson/DescriptorJson 둘 다에서 최대한 회수)
            function buildEditableA1Set(desc, inp) {
                const set = new Set();
                const rxA1 = /^[A-Z]+\d+$/;

                function addMaybeA1(v) {
                    if (!v) return;
                    const s = String(v).trim().toUpperCase();
                    if (rxA1.test(s)) set.add(s);
                }

                function walk(obj) {
                    if (!obj) return;
                    if (Array.isArray(obj)) { obj.forEach(walk); return; }
                    if (typeof obj !== 'object') { addMaybeA1(obj); return; }

                    for (const k in obj) {
                        if (!Object.prototype.hasOwnProperty.call(obj, k)) continue;
                        const v = obj[k];

                        // key 자체가 A1인 케이스도 흡수
                        addMaybeA1(k);

                        // 흔한 필드명 케이스 흡수
                        if (k === 'a1' || k === 'A1' || k === 'cellA1' || k === 'CellA1') addMaybeA1(v);

                        walk(v);
                    }
                }

                walk(inp);
                walk(desc);
                return set;
            }

            const __editableA1 = buildEditableA1Set(descriptor, inputs);
            const excelColWidthToPx = W => {
                const w = Number(W);
                if (!isFinite(w) || w < 0) return 0;
                return Math.max(0, Math.floor(w * 7 + 5));
            };
            const ptToPx = pt => ((Number(pt) || 0) * 96 / 72);

            function colIndexToLetters(colIndex) {
                var n = Number(colIndex) || 0;
                var s = "";  
                while (n > 0) {
                    n--;
                    s = String.fromCharCode(65 + (n % 26)) + s;
                    n = Math.floor(n / 26);
                }
                return s || "A";
            }

            function hasVisibleStyle(st) {
                if (!st) return false;
                if (st.fill && st.fill.bg) return true;
                if (st.font && (st.font.bold || st.font.italic || st.font.underline || st.font.size || st.font.name))
                    return true;
                const b = st.border || {};
                return !!((b.l && b.l !== 'None') || (b.r && b.r !== 'None') ||
                    (b.t && b.t !== 'None') || (b.b && b.b !== 'None'));
            }

            function measureEffectiveContentWidth(tbl) {
                if (!tbl) return 0;
                const baseLeft = tbl.getBoundingClientRect().left;
                let maxRight = 0;
                for (const td of tbl.querySelectorAll('td')) {
                    const cs = getComputedStyle(td);
                    const hasBorder =
                        ((parseFloat(cs.borderLeftWidth) || 0) > 0) ||
                        ((parseFloat(cs.borderRightWidth) || 0) > 0) ||
                        ((parseFloat(cs.borderTopWidth) || 0) > 0) ||
                        ((parseFloat(cs.borderBottomWidth) || 0) > 0);
                    const hasText = (td.textContent || '').trim().length > 0;
                    const isEditable = td.classList.contains('eb-editable');
                    if (hasBorder || hasText || isEditable) {
                        const r = td.getBoundingClientRect().right;
                        if (r > maxRight) maxRight = r;
                    }
                }
                const eff = Math.ceil(maxRight - baseLeft);
                return (isFinite(eff) && eff > 0) ? eff : 0;
            }

            function mountPreview() {
                const xhost = document.getElementById('xhost');
                if (!xhost) return;

                try {
                    if (!preview || !Array.isArray(preview.cells) || !preview.cells.length) {
                        xhost.innerHTML =
                            `<div class="alert alert-danger mb-0 py-1">${T("DOC_Err_PreviewFailed")}</div>`;
                        return;
                    }

                    const p = preview;
                    const styles = p.styles || {};
                    let minR = Infinity, maxR = -Infinity, minC = Infinity, maxC = -Infinity;

                    function mark(r, c) {
                        minR = Math.min(minR, r);
                        maxR = Math.max(maxR, r);
                        minC = Math.min(minC, c);
                        maxC = Math.max(maxC, c);
                    }

                    for (let r = 1; r <= p.cells.length; r++) {
                        const row = p.cells[r - 1] || [];
                        for (let c = 1; c <= row.length; c++) {
                            const v = row[c - 1];
                            if (v !== '' && v != null) mark(r, c);
                            const st = styles[`${r},${c}`];
                            if (hasVisibleStyle(st)) mark(r, c);
                        }
                    }

                    (p.merges || []).forEach(m => {
                        const [r1, c1, r2, c2] = m.map(n => parseInt(n, 10) || 0);
                        mark(r1, c1); mark(r2, c2);
                    });

                    if (!isFinite(minR) || !isFinite(minC)) {
                        minR = 1; maxR = Math.max(1, (p.rows || 1));
                        minC = 1; maxC = Math.max(1, (p.cols || 1));
                    }

                    const maxColsFromCells = Math.max(...p.cells.map(r => r.length), 1);
                    maxC = Math.min(maxC, maxColsFromCells);
                    minC = Math.max(minC, 1);

                    const mergeMap = new Map();
                    (p.merges || []).forEach(m => {
                        let [r1, c1, r2, c2] = m.map(n => parseInt(n, 10));
                        r1 = Math.max(r1, minR);
                        c1 = Math.max(c1, minC);
                        r2 = Math.min(r2, maxR);
                        c2 = Math.min(c2, maxC);
                        if (r1 > r2 || c1 > c2) return;
                        const master = `${r1}-${c1}`;
                        mergeMap.set(master, { master: true, rs: r2 - r1 + 1, cs: c2 - c1 + 1 });
                        for (let rr = r1; rr <= r2; rr++) {
                            for (let cc = c1; cc <= c2; cc++) {
                                const k = `${rr}-${cc}`;
                                if (k !== master) mergeMap.set(k, { covered: true });
                            }
                        }
                    });

                    const styleGrid = [];
                    for (let r = minR; r <= maxR; r++) {
                        styleGrid[r] = styleGrid[r] || [];
                        for (let c = minC; c <= maxC; c++) {
                            const key = `${r},${c}`;
                            const st = styles[key] || {};
                            const border = Object.assign(
                                { l: 'None', r: 'None', t: 'None', b: 'None' },
                                st.border || {});
                            styleGrid[r][c] = {
                                font: st.font || null,
                                align: st.align || null,
                                fill: st.fill || null,
                                border
                            };
                        }
                    }

                    const weight = s => {
                        s = String(s || '').toLowerCase();
                        if (!s || s === 'none') return 0;
                        if (s.includes('double')) return 6;
                        if (s.includes('thick')) return 5;
                        if (s.includes('mediumdashdotdot') || s.includes('mediumdashdot') ||
                            s.includes('mediumdashed') || s.includes('medium')) return 4;
                        if (s.includes('dashed') || s.includes('dashdot') || s.includes('dashdotdot')) return 3;
                        if (s.includes('dotted') || s.includes('hair')) return 2;
                        return 1;
                    };
                    const stronger = (a, b) => (weight(a) >= weight(b) ? a : b);

                    for (let r = minR; r <= maxR; r++) {
                        for (let c = minC; c <= maxC; c++) {
                            const cur = styleGrid[r][c];
                            if (!cur) continue;
                            if (c < maxC) {
                                const right = styleGrid[r][c + 1];
                                if (right) {
                                    const pick = stronger(cur.border.r, right.border.l);
                                    cur.border.r = pick;
                                    right.border.l = pick;
                                }
                            }
                            if (r < maxR) {
                                const down = styleGrid[r + 1][c];
                                if (down) {
                                    const pick = stronger(cur.border.b, down.border.t);
                                    cur.border.b = pick;
                                    down.border.t = pick;
                                }
                            }
                        }
                    }

                    const colPxAt = c => {
                        const wChar = (p.colW || [])[c - 1];
                        return excelColWidthToPx(wChar ?? 8.43);
                    };
                    const sumColPx = (c1, c2) => {
                        let s = 0;
                        for (let i = c1; i <= c2; i++) s += colPxAt(i);
                        return s;
                    };

                    const tbl = document.createElement('table');
                    tbl.className = 'xlfb';

                    const colgroup = document.createElement('colgroup');
                    for (let c = minC; c <= maxC; c++) {
                        const cg = document.createElement('col');
                        cg.style.width = colPxAt(c).toFixed(2) + 'px';
                        colgroup.appendChild(cg);
                    }
                    tbl.appendChild(colgroup);

                    const tbody = document.createElement('tbody');
                    const rowHeights = Array.isArray(p.rowH) ? p.rowH : [];
                    const DEFAULT_ROW_PT = 15;

                    function applyStyleToCell(td, cell, st) {
                        if (!st || typeof st !== 'object') return;

                        const isEditable =
                            !!(td && (
                                (td.classList && (td.classList.contains('eb-editable') || td.classList.contains('eb-group')))
                                || td.hasAttribute('data-key')
                            ));

                        const font = st.font || null;
                        if (font) {
                            if (font.bold) cell.style.fontWeight = '700';
                            if (font.italic) cell.style.fontStyle = 'italic';
                            if (font.underline) cell.style.textDecoration = 'underline';

                            // ★ 매핑/입력 셀은 폰트/크기만 고정 정책이므로 Excel font.size/name 적용을 스킵
                            if (!isEditable) {
                                if (font.size != null) {
                                    const pt = Number(font.size);
                                    if (isFinite(pt) && pt > 0) {
                                        cell.style.fontSize = ptToPx(pt).toFixed(2) + 'px';
                                    }
                                }
                                if (font.name) {
                                    cell.style.fontFamily =
                                        `"${font.name}", '맑은 고딕', 'Malgun Gothic', dotum, Arial, sans-serif`;
                                }
                            }
                        }

                        if (st.align) {
                            const h = String(st.align.h || '').toLowerCase();
                            if (h === 'center') cell.classList.add('ta-center');
                            else if (h === 'right') cell.classList.add('ta-right');
                            else cell.classList.add('ta-left');

                            const v = String(st.align.v || '').toLowerCase();
                            if (v === 'top') td.classList.add('va-top');
                            else if (v === 'center' || v === 'middle') td.classList.add('va-middle');
                            else td.classList.add('va-bottom');

                            if (st.align.wrap) cell.classList.add('wrap');
                        }

                        const cssOf = s => {
                            s = String(s || '').toLowerCase();
                            if (!s || s === 'none') return { w: 0, sty: 'none' };
                            if (s.includes('double')) return { w: 3, sty: 'double' };
                            if (s.includes('mediumdashdotdot') || s.includes('mediumdashdot') || s.includes('mediumdashed'))
                                return { w: 2, sty: 'dashed' };
                            if (s.includes('dashdotdot') || s.includes('dashdot') || s.includes('dashed'))
                                return { w: 1, sty: 'dashed' };
                            if (s.includes('dotted') || s.includes('hair'))
                                return { w: 1, sty: 'dotted' };
                            if (s.includes('thick')) return { w: 3, sty: 'solid' };
                            if (s.includes('medium')) return { w: 2, sty: 'solid' };
                            return { w: 1, sty: 'solid' };
                        };

                        const color = '#000';
                        if (st.border) {
                            const L = cssOf(st.border.l), R = cssOf(st.border.r),
                                T0 = cssOf(st.border.t), B0 = cssOf(st.border.b);
                            td.style.borderLeft = L.w ? `${L.w}px ${L.sty} ${color}` : 'none';
                            td.style.borderRight = R.w ? `${R.w}px ${R.sty} ${color}` : 'none';
                            td.style.borderTop = T0.w ? `${T0.w}px ${T0.sty} ${color}` : 'none';
                            td.style.borderBottom = B0.w ? `${B0.w}px ${B0.sty} ${color}` : 'none';
                        }
                    }

                    for (let r = minR; r <= maxR; r++) {
                        const tr = document.createElement('tr');
                        const pt = (rowHeights[r - 1] != null) ? rowHeights[r - 1] : DEFAULT_ROW_PT;
                        const rowPx = ptToPx(pt);
                        tr.style.height = rowPx + 'px';

                        for (let c = minC; c <= maxC; c++) {
                            const key = `${r}-${c}`;
                            const mm = mergeMap.get(key);
                            if (mm && mm.covered) continue;

                            const td = document.createElement('td');

                            const a1Label = colIndexToLetters(c) + String(r);
                            td.dataset.a1 = a1Label;
                            td.dataset.r = r;
                            td.dataset.c = c;

                            // ★ 매핑/입력 셀 표시 (방법 A의 핵심)
                            if (__editableA1.has(String(a1Label).toUpperCase())) {
                                td.classList.add('eb-editable');
                                td.setAttribute('data-key', a1Label); // key를 별도로 쓰면 여기만 교체
                            }

                            if (mm && mm.master) {
                                if (mm.rs > 1) td.setAttribute('rowspan', String(mm.rs));
                                if (mm.cs > 1) td.setAttribute('colspan', String(mm.cs));
                            }
                            if (!(mm && mm.master && mm.cs > 1)) {
                                td.style.width = colPxAt(c) + 'px';
                            }

                            const cellDiv = document.createElement('div');
                            cellDiv.className = 'cellc';
                            if (!mm) cellDiv.style.maxHeight = rowPx + 'px';
                            const isEditableCell = td.classList.contains('eb-editable')
                                || td.classList.contains('eb-group')
                                || td.hasAttribute('data-key');
                            if (cellDiv.classList.contains('wrap')) {
                                cellDiv.style.whiteSpace = 'pre-wrap';
                            } else if (isEditableCell) {
                                cellDiv.style.whiteSpace = 'pre';
                                cellDiv.style.wordBreak = 'normal';
                            }

                            const raw = p.cells[r - 1]?.[c - 1] ?? '';
                            if (raw !== '' && raw != null) {
                                cellDiv.appendChild(document.createTextNode(String(raw)));
                            }

                            applyStyleToCell(td, cellDiv, styleGrid[r][c]);
                            td.appendChild(cellDiv);
                            tr.appendChild(td);
                        }
                        tbody.appendChild(tr);
                    }

                    tbl.appendChild(tbody);

                    const totalW = sumColPx(minC, maxC);
                    tbl.style.width = totalW + 'px';

                    xhost.innerHTML = '';
                    xhost.appendChild(tbl);

                    const effW = measureEffectiveContentWidth(tbl) || totalW;

                    window.__DOC_TOTALW__ = Math.max(1, totalW | 0);
                    window.__DOC_EFFW__ = Math.max(1, effW | 0);

                    const finalW = Math.min(window.__DOC_EFFW__ || window.__DOC_TOTALW__, window.__DOC_TOTALW__);
                    xhost.style.width = finalW + 'px';
                    window.__DOC_FINALW__ = finalW;

                    try {
                        renderApprovalSignaturesOnCurrentPreview(tbl);
                    } catch (sigErr) {
                        console.warn('renderApprovalSignaturesOnCurrentPreview error', sigErr);
                    }
                } catch (e) {
                    console.error(e);
                    xhost.innerHTML =
                        `<div class="alert alert-danger mb-0 py-1">${T("DOC_Err_PreviewFailed")}</div>`;
                }
            }

            if (document.readyState === 'loading') {
                document.addEventListener('DOMContentLoaded', mountPreview, { once: true });
            } else {
                mountPreview();
            }
        })();

        const docId = "@(docId ?? "")";
        const compCd = "@(compCd ?? "")";

        // ★ 작성자/상태/시간 정보는 data-* 에서 읽어오도록 변경 (Razor Json 직렬화 에러 방지)
        const __root = document.querySelector('.doc-detail-root');
        const docStatus = (__root?.getAttribute('data-status') || '').toString();
        const docCreatorNameRaw = (__root?.getAttribute('data-creator-name') || '').toString();
        const docCreatedAtText = (__root?.getAttribute('data-created-at') || '').toString();
        const docRecalledAtText = (__root?.getAttribute('data-recalled-at') || '').toString();


        // ===== UserId 기반 서명 스탬프 렌더링 =====
        function renderApprovalSignaturesOnCurrentPreview(tbl) {
            var approvals = window.approvalsData;
            var cellMap = window.APPROVAL_SIGN_CELL_MAP;

            console.log('DBG approvalsData', approvals);
            console.log('DBG APPROVAL_SIGN_CELL_MAP', cellMap);

            if (!Array.isArray(approvals) || !cellMap || typeof cellMap !== 'object') {
                console.log('DBG no approvals or no cellMap, skip signature render');
                return;
            }

            function colLettersToIndex(colLetters) {
                var s = String(colLetters || '').toUpperCase();
                var n = 0;
                for (var i = 0; i < s.length; i++) {
                    var code = s.charCodeAt(i);
                    if (code < 65 || code > 90) return NaN;
                    n = n * 26 + (code - 64);
                }
                return n;
            }

            // ★ 공용/개인 모두 /images/signatures 가 루트 URL 이고
            //   물리 경로는 Program.cs 에서 App_Data\Signature 로 매핑합니다.
            var STAMP_BASE = '/images/signatures/';
            var HOLDING_STAMP = STAMP_BASE + 'holding.png';
            var REJECTED_STAMP = STAMP_BASE + 'rejected.png';
            var APPROVED_STAMP = STAMP_BASE + 'approved.png';

            approvals.forEach(function (a, idx) {
                var actionRaw = (a.action || a.Action || '').toString().toUpperCase();
                var statusRaw = (a.status || a.Status || '').toString().toUpperCase();

                // step 계산(기존 그대로)
                var rawStep =
                    a.step || a.stepOrder || a.Step || a.StepOrder;
                var numericStep = parseInt(rawStep, 10);
                if (!numericStep || !isFinite(numericStep)) {
                    numericStep = idx + 1;
                }
                var step = numericStep;

                var a1 = cellMap[step] || cellMap[String(step)];
                if (!a1) {
                    console.warn('DBG no A1 mapping for step', step, 'rawStep', rawStep, a);
                    return;
                }

                // ★ DB 에서 넘어온 개인 서명 상대경로 (예: "0001/8bf4....png")
                var sigPathRaw = (a.signaturePath || a.SignaturePath || '').toString().trim();

                var stampUrl = null;

                if (actionRaw === 'APPROVE' || statusRaw === 'APPROVED') {
                    if (sigPathRaw) {
                        // "0001\abc.png" → "0001/abc.png", 선행 슬래시는 제거
                        var normalized = sigPathRaw
                            .replace(/^[\\/]+/, '')
                            .replace(/\\/g, '/');
                        stampUrl = STAMP_BASE + normalized;
                    } else {
                        // 개인 서명 경로가 없으면 공용 approved.png 사용
                        stampUrl = APPROVED_STAMP;
                    }
                } else if (actionRaw === 'HOLD'
                    || statusRaw === 'HOLD'
                    || statusRaw === 'ONHOLD') {
                    stampUrl = HOLDING_STAMP;
                } else if (actionRaw === 'REJECT'
                    || statusRaw === 'REJECT'
                    || statusRaw === 'REJECTED') {
                    stampUrl = REJECTED_STAMP;
                }

                if (!stampUrl) {
                    console.log('DBG skip signature by status', statusRaw || actionRaw, a);
                    return;
                }

                var td = tbl.querySelector('td[data-a1="' + a1 + '"]');

                if (!td && /^[A-Z]+$/i.test(a1)) {
                    var colIndex = colLettersToIndex(a1);
                    console.log('DBG only-column A1, colIndex', a1, colIndex);

                    if (!isNaN(colIndex)) {
                        var candidates = Array.from(tbl.querySelectorAll('td[data-c]'))
                            .filter(function (cell) {
                                return Number(cell.dataset.c || 0) === colIndex;
                            });

                        console.log('DBG candidates for column', a1, '=>', candidates.length);

                        if (candidates.length > 0) {
                            candidates.sort(function (c1, c2) {
                                return Number(c1.dataset.r || 0) - Number(c2.dataset.r || 0);
                            });
                            td = candidates[0];
                        }
                    }
                }

                if (!td) {
                    console.warn('DBG signature td not found for A1', a1, 'step', step);
                    return;
                }

                td.innerHTML = '';
                td.classList.add('doc-approval-cell');

                var img = document.createElement('img');

                // ★ 개인 서명 로딩 실패 시 공용 approved.png 로 1회 fallback
                if (actionRaw === 'APPROVE' || statusRaw === 'APPROVED') {
                    img.onerror = function () {
                        if (this.dataset.fallbackTried === '1') return;
                        this.dataset.fallbackTried = '1';
                        console.warn('DBG personal stamp load failed, fallback to common approved', this.src);
                        this.src = APPROVED_STAMP;
                    };
                }

                img.src = stampUrl;
                img.alt = 'approval-stamp';
                img.className = 'doc-approval-cell-img';
                td.appendChild(img);

                var captionText = getApprovalDisplayName(a);
                if (captionText) {
                    var parts = captionText.split(/\s+/);
                    if (parts.length >= 3) {
                        captionText = parts.slice(parts.length - 2).join(' ');
                    } else if (parts.length === 2) {
                        captionText = parts.join(' ');
                    }
                }

                if (captionText) {
                    var cap = document.createElement('div');
                    cap.textContent = captionText;
                    cap.className = 'doc-approval-caption';
                    td.appendChild(cap);
                }

                console.log('DBG placed signature image', {
                    idx: idx,
                    step: step,
                    rawStep: rawStep,
                    a1: a1,
                    url: stampUrl,
                    caption: captionText,
                    cellA1: td.dataset.a1,
                    r: td.dataset.r,
                    c: td.dataset.c
                });
            });
        }

        // ★ 상세 타이틀을 "작성자님의 문서이름" 형식으로 맞추기 (creatorName 없으면 결재자 이름 사용)
        (function updateDetailTitle() {
            const root = document.querySelector('.doc-detail-root');
            const titleEl = document.querySelector('.doc-detail-title');
            if (!root || !titleEl) return;

            const docTitle = (root.getAttribute('data-doc-title') || titleEl.textContent || '').trim();

            // 1차: ViewBag에서 넘어온 작성자 정보에서 "이름만"
            const rawCreator = (root.getAttribute('data-creator-name') || '').trim();
            let creator = extractPersonName(rawCreator);

            // 2차: 작성자 정보가 없으면 첫 번째 결재자의 이름을 사용
            if (!creator && Array.isArray(window.approvalsData) && window.approvalsData.length > 0) {
                const firstDisplay = getApprovalDisplayName(window.approvalsData[0]) || '';
                const approverName = extractPersonName(firstDisplay);
                if (approverName) creator = approverName;
            }

            if (creator && docTitle) {
                titleEl.textContent = `${creator}님의 ${docTitle}`;
            } else if (docTitle) {
                titleEl.textContent = docTitle;
            }
        })();

        // ================== 댓글 & 파일 업로드 ==================
        // 2025.12.04 Changed: 댓글/대댓글 수정·삭제 버튼 추가, 하위 답글 존재 시 수정/삭제 차단
        (function initComments() {
            const EBV = window.EBValidate || {};
            const rawFetch = (window.fetch || function () { }).bind(window);

            const EBC = (window.EBCSRF || window.EBCsrf) || {
                async fetch(url, options) {
                    const res = await rawFetch(url, options || {});
                    return res;
                },
                async json(url, payload, method = 'POST') {
                    const res = await rawFetch(url, {
                        method,
                        headers: {
                            'Content-Type': 'application/json',
                            'Accept': 'application/json'
                        },
                        body: method === 'GET' ? undefined : JSON.stringify(payload || {})
                    });
                    const j = await res.json().catch(() => ({}));
                    if (!res.ok) {
                        const err = new Error('request failed');
                        err.payload = j;
                        throw err;
                    }
                    return j;
                }
            };

            const $list = document.getElementById('cmt-list');
            const $alert = document.getElementById('cmt-alert');
            const $count = document.getElementById('cmt-count');
            const $fileIn = document.getElementById('cmt-file');
            const $fileList = document.getElementById('cmt-file-list');
            const $body = document.getElementById('cmt-body');
            const $submit = document.getElementById('cmt-submit');

            /* ★ 깊이별 들여쓰기 간격: 한 단계당 40px */
            const COMMENT_DEPTH_INDENT = 40;

            const docIdAttr = document.querySelector('.doc-detail-root')?.getAttribute('data-doc-id') || '';
            if (!docIdAttr) {
                showErr([T('DOC_Err_DocumentNotFound')]);
                return;
            }

            let pendingFiles = [];
            let activeReply = null; // { parentId, form }
            let activeEdit = null;  // { commentId, form, bodyHost }

            // 파일 업로드 UI는 현재 주석 처리 상태이므로, 요소가 있을 때만 안전하게 이벤트 연결
            if ($fileIn) {
                $fileIn.addEventListener('change', () => {
                    pendingFiles = Array.from($fileIn.files || []);
                    renderFileList();
                });
            }

            if ($fileList) {
                $fileList.addEventListener('click', (e) => {
                    const btn = e.target.closest('button[data-remove]');
                    if (!btn) return;
                    const idx = Number(btn.getAttribute('data-remove'));
                    if (!Number.isNaN(idx)) {
                        pendingFiles.splice(idx, 1);
                        if ($fileIn) $fileIn.value = '';
                        renderFileList();
                    }
                });
            }

            function renderFileList() {
                if (!$fileList) return;
                $fileList.innerHTML = '';
                pendingFiles.forEach((f, i) => {
                    const li = document.createElement('li');
                    li.innerHTML =
                        `<span>${escapeHtml(f.name)}</span>
                                 <span class="text-muted">(${Number(f.size || 0).toLocaleString()})</span>
                                 <button type="button" class="btn btn-outline-secondary btn-sm" data-remove="${i}">&times;</button>`;
                    $fileList.append(li);
                });
            }

            async function loadComments() {
                try {
                    const res = await EBC.fetch('/Doc/Comments?docId=' + encodeURIComponent(docIdAttr), {
                        method: 'GET',
                        headers: { 'Accept': 'application/json' }
                    });
                    const data = await res.json().catch(() => ({}));
                    const items = Array.isArray(data.items) ? data.items : [];
                    renderComments(items);
                } catch (e) {
                    console.error('loadComments error', e);
                    showErr([T('DOC_Err_LoadFailed')]);
                }
            }

            function renderComments(items) {
                $list.innerHTML = '';
                activeReply = null;

                if (!items.length) {
                    $count.textContent = '';
                    $list.innerHTML = `<div class="text-muted">${T('DOC_Msg_NoComments')}</div>`;
                    return;
                }

                $count.textContent = T('DOC_Cmt_Count').replace('{n}', items.length);

                items.forEach(c => {
                    const wrap = document.createElement('div');
                    wrap.className = 'doc-comment-item';

                    // ===== 들여쓰기 보정 (depth × 고정 간격) =====
                    const depthRaw = (typeof c.depth === 'number')
                        ? c.depth
                        : parseInt(c.depth || '0', 10) || 0;
                    const depth = Math.max(0, Math.min(depthRaw, 4));   // 0~4 단계만 허용
                    wrap.style.marginLeft = (depth * COMMENT_DEPTH_INDENT) + 'px';
                    // ===========================================

                    const cid = c.id || c.commentId || c.CommentId;
                    if (cid != null) {
                        wrap.dataset.commentId = String(cid);
                    }

                    let actionsHtml = '';
                    if (cid != null) {
                        const canEdit = !!c.canEdit;
                        const canDelete = !!c.canDelete;
                        const btns = [];

                        btns.push(
                            `<button type="button"
                                      class="btn btn-link btn-sm p-0"
                                      data-reply-id="${String(cid)}">
                                 ${escapeHtml(T('DOC_Btn_Reply'))}
                             </button>`
                        );

                        if (canEdit) {
                            btns.push(
                                `<button type="button"
                                          class="btn btn-link btn-sm p-0 ms-2"
                                          data-edit-id="${String(cid)}">
                                     ${escapeHtml(T('_CM_Edit'))}
                                 </button>`
                            );
                        }

                        if (canDelete) {
                            btns.push(
                                `<button type="button"
                                          class="btn btn-link btn-sm p-0 ms-2 text-danger"
                                          data-delete-id="${String(cid)}">
                                     ${escapeHtml(T('_CM_Delete'))}
                                 </button>`
                            );
                        }

                        actionsHtml = `<span class="ms-auto">${btns.join(' ')}</span>`;
                    }

                    wrap.innerHTML = `
                        <div class="doc-comment-meta d-flex align-items-center">
                            <span><strong>${escapeHtml(c.createdBy || '')}</strong></span>
                            <span class="ms-2">${escapeHtml(c.createdAt || '')}</span>
                            ${actionsHtml}
                        </div>
                        <div class="doc-comment-body">${nl2br(escapeHtml(c.body || ''))}</div>
                    `;
                    $list.append(wrap);
                });
            }

            $submit?.addEventListener('click', async () => {
                const body = ($body.value || '').trim();
                if (!body) {
                    showErr([T('DOC_Val_Required')]);
                    return;
                }

                try {
                    const payload = {
                        docId: docIdAttr,
                        parentCommentId: null,
                        body: body,
                        files: []
                    };

                    await EBC.json('/Doc/Comments', payload, 'POST');

                    $body.value = '';
                    pendingFiles = [];
                    if ($fileIn) $fileIn.value = '';
                    renderFileList();

                    //showInfo([T('DOC_Msg_CommentCreated')]);
                    await loadComments();
                } catch (e) {
                    console.error('post comment error', e);
                    const p = e && e.payload;
                    showErr(p?.messages || [T('DOC_Err_SaveFailed')], p?.fieldErrors);
                }
            });

            // 댓글 리스트 영역 이벤트 위임
            $list.addEventListener('click', async (e) => {
                const replyBtn = e.target.closest('button[data-reply-id]');
                const editBtn = e.target.closest('button[data-edit-id]');
                const deleteBtn = e.target.closest('button[data-delete-id]');

                if (replyBtn) {
                    const parentId = replyBtn.getAttribute('data-reply-id');
                    const item = replyBtn.closest('.doc-comment-item');
                    if (!parentId || !item) return;
                    toggleReplyForm(parentId, item);
                    return;
                }

                if (editBtn) {
                    const cid = editBtn.getAttribute('data-edit-id');
                    const item = editBtn.closest('.doc-comment-item');
                    if (!cid || !item) return;
                    toggleEditForm(cid, item);
                    return;
                }

                if (deleteBtn) {
                    const cid = deleteBtn.getAttribute('data-delete-id');
                    if (!cid) return;
                    if (!confirm(T('DOC_Confirm_DeleteComment') || '삭제하시겠습니까?')) return;

                    try {
                        const url = `/Doc/Comments/${encodeURIComponent(cid)}?docId=${encodeURIComponent(docIdAttr)}`;
                        const res = await EBC.fetch(url, {
                            method: 'DELETE',
                            headers: { 'Accept': 'application/json' }
                        });
                        const j = await res.json().catch(() => ({}));
                        if (!res.ok || j.ok === false) {
                            throw { payload: j };
                        }
                        await loadComments();
                    } catch (err) {
                        console.error('delete comment error', err);
                        const p = err && err.payload;
                        showErr(p?.messages || [T('DOC_Err_DeleteFailed')]);
                    }
                    return;
                }

                const submitBtn = e.target.closest('button[data-reply-submit]');
                if (submitBtn) {
                    const form = submitBtn.closest('.doc-comment-reply');
                    if (!form || !activeReply || !activeReply.parentId) return;

                    const textarea = form.querySelector('textarea');
                    const body = (textarea?.value || '').trim();
                    if (!body) {
                        showErr([T('DOC_Val_Required')]);
                        return;
                    }

                    try {
                        const payload = {
                            docId: docIdAttr,
                            parentCommentId: activeReply.parentId,
                            parentId: activeReply.parentId,
                            body: body,
                            files: []
                        };

                        await EBC.json('/Doc/Comments', payload, 'POST');

                        if (textarea) textarea.value = '';
                        removeReplyForm();
                        await loadComments();
                    } catch (err) {
                        console.error('reply comment error', err);
                        const p = err && err.payload;
                        showErr(p?.messages || [T('DOC_Err_SaveFailed')]);
                    }
                    return;
                }

                const cancelBtn = e.target.closest('button[data-reply-cancel]');
                if (cancelBtn) {
                    removeReplyForm();
                }
            });

            function toggleReplyForm(parentId, itemEl) {
                if (activeReply && activeReply.parentId === parentId) {
                    removeReplyForm();
                    return;
                }
                removeReplyForm();

                const form = document.createElement('div');
                form.className = 'doc-comment-reply mt-2';

                // 부모 댓글 들여쓰기 + 절반 정도만 더 들여쓰기
                const parentIndent = parseInt(
                    window.getComputedStyle(itemEl).marginLeft || '0',
                    10
                ) || 0;
                form.style.marginLeft = (parentIndent + COMMENT_DEPTH_INDENT / 2) + 'px';

                form.innerHTML = `
                    <textarea class="form-control form-control-sm mb-1"
                              rows="2"
                              placeholder="${escapeHtml(T('DOC_Placeholder_Reply'))}"></textarea>
                    <div class="d-flex gap-2 justify-content-end">
                        <button type="button"
                                class="btn btn-sm btn-primary"
                                data-reply-submit>
                            ${escapeHtml(T('DOC_Btn_ReplyPost'))}
                        </button>
                        <button type="button"
                                class="btn btn-sm btn-outline-secondary"
                                data-reply-cancel>
                            ${escapeHtml(T('DOC_Btn_Cancel'))}
                        </button>
                    </div>
                `;

                itemEl.append(form);
                activeReply = { parentId: parentId, form: form };
            }

            function removeReplyForm() {
                if (activeReply && activeReply.form && activeReply.form.parentNode) {
                    activeReply.form.parentNode.removeChild(activeReply.form);
                }
                activeReply = null;
            }


            function toggleEditForm(commentId, itemEl) {
                const existing = itemEl.querySelector('.doc-comment-edit');
                if (existing) {
                    existing.remove();
                    return;
                }

                const bodyEl = itemEl.querySelector('.doc-comment-body');
                const originalText = bodyEl ? bodyEl.textContent || '' : '';

                const form = document.createElement('div');
                form.className = 'doc-comment-edit mt-1';
                form.innerHTML = `
                            <textarea class="form-control form-control-sm mb-1"
                                      rows="2">${escapeHtml(originalText)}</textarea>
                            <div class="d-flex gap-2 justify-content-end">
                                <button type="button"
                                        class="btn btn-sm btn-primary"
                                        data-edit-submit="${commentId}">
                                    ${escapeHtml(T('_CM_Edit'))}
                                </button>
                                <button type="button"
                                        class="btn btn-sm btn-outline-secondary"
                                        data-edit-cancel>
                                    ${escapeHtml(T('DOC_Btn_Cancel'))}
                                </button>
                            </div>
                        `;
                itemEl.append(form);

                form.addEventListener('click', async (e) => {
                    const submit = e.target.closest('button[data-edit-submit]');
                    const cancel = e.target.closest('button[data-edit-cancel]');

                    if (cancel) {
                        form.remove();
                        return;
                    }

                    if (submit) {
                        const tid = submit.getAttribute('data-edit-submit');
                        const textarea = form.querySelector('textarea');
                        const body = (textarea?.value || '').trim();
                        if (!body) {
                            showErr([T('DOC_Val_Required')]);
                            return;
                        }

                        try {
                            const payload = { docId: docIdAttr, body };
                            const url = `/Doc/Comments/${encodeURIComponent(tid)}`;
                            await EBC.json(url, payload, 'PUT');
                            await loadComments();
                        } catch (err) {
                            console.error('update comment error', err);
                            const p = err && err.payload;
                            showErr(p?.messages || [T('DOC_Err_SaveFailed')]);
                        }
                    }
                }, { once: true });
            }

            function showErr(msgs) {
                if (EBV.showAlert) {
                    EBV.showAlert('cmt-alert', msgs, { variant: 'danger' });
                } else {
                    $alert.innerHTML =
                        `<div class="alert alert-danger py-1 mb-1">${(msgs || []).map(escapeHtml).join('<br>')}</div>`;
                }
            }

            function showInfo(msgs) {
                if (EBV.showAlert) {
                    EBV.showAlert('cmt-alert', msgs, { variant: 'success' });
                } else {
                    $alert.innerHTML =
                        `<div class="alert alert-success py-1 mb-1">${(msgs || []).map(escapeHtml).join('<br>')}</div>`;
                }
            }

            function escapeHtml(s) {
                return String(s || '').replace(/[&<>"']/g,
                    m => ({ '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#39;' }[m]));
            }

            function nl2br(s) {
                return String(s || '').replace(/\n/g, '<br>');
            }

            loadComments();
        })();

        // ================== 조회 로그 ==================
        (function renderViewLogs() {
            const host = document.getElementById('viewlog-list');
            if (!host) return;

            let logs;
            try { logs = JSON.parse('@Html.Raw(viewLogsJson)'); }
            catch { logs = null; }

            if (!Array.isArray(logs) || !logs.length) {
                host.innerHTML = `<div class="text-muted">${T('DOC_Msg_NoViewLogs')}</div>`;
                return;
            }

            logs.sort((a, b) => (a.viewedAt || '').localeCompare(b.viewedAt || ''));
            const seen = new Set();
            const rows = [];

            logs.forEach(v => {
                const key = v.userId || v.userName || '';
                if (!key) return;
                if (seen.has(key)) return;
                seen.add(key);
                rows.push(v);
            });

            if (!rows.length) {
                host.innerHTML = `<div class="text-muted">${T('DOC_Msg_NoViewLogs')}</div>`;
                return;
            }

            host.innerHTML = '';
            rows.forEach(v => {
                const row = document.createElement('div');
                const when = v.viewedAtText || v.viewedAt || '';
                const who = v.userName || v.userId || '';
                row.textContent = `${when} - ${who}`;
                host.append(row);
            });
        })();

        // ================== 승인 정보 ==================
        (function renderApprovals() {
            const tbody = document.getElementById('tbody-approvals');
            if (!tbody) return;

            const esc = s => String(s || '').replace(/[&<>"']/g,
                m => ({ '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#39;' }[m]));

            let approvals = [];
            if (Array.isArray(window.approvalsData)) approvals = window.approvalsData.slice();
            else {
                try {
                    const parsed = JSON.parse('@Html.Raw(approvalsJson)');
                    if (Array.isArray(parsed)) approvals = parsed.slice();
                } catch { approvals = []; }
            }

            const __root = document.querySelector('.doc-detail-root');

            const docStatus = (__root?.getAttribute('data-status') || '').toString();
            const isDocRecalled = String(docStatus || '').toUpperCase() === 'RECALLED';

            // 작성자 이름(이름만)
            const docCreatorNameRaw = (__root?.getAttribute('data-creator-name') || '').toString();
            const authorFull = (docCreatorNameRaw || '').trim();
            const authorNameOnly = (function () {
                const n = extractPersonName(authorFull);
                return n || authorFull;
            })();

            // 작성/회수 시각 (서버에서 data-* 로 내려줘야 함)
            let createdText = ((__root?.getAttribute('data-created-at') || '') + '').trim();
            let recalledText = ((__root?.getAttribute('data-recalled-at') || '') + '').trim();

            if (!createdText && __root) createdText = ((__root.dataset.createdAt || '') + '').trim();
            if (!recalledText && __root) recalledText = ((__root.dataset.recalledAt || '') + '').trim();

            // StepOrder 기준 정렬 (approvals가 비어있어도 작성자행은 렌더링해야 하므로, 정렬은 그냥 수행)
            approvals.sort((a, b) =>
                (a.step || a.stepOrder || a.Step || a.StepOrder || 0) -
                (b.step || b.stepOrder || b.Step || b.StepOrder || 0));

            const rows = [];

            // 1) 작성자 1행 (항상)
            let authorStatusText = '';
            let authorWhenText = '';
            if (isDocRecalled) {
                authorStatusText = T('DOC_Status_Recalled');
                authorWhenText = recalledText;
            } else {
                authorStatusText = T('DOC_Status_Created');
                authorWhenText = createdText;
            }

            rows.push({
                name: authorNameOnly || '',
                statusText: authorStatusText || '',
                whenText: authorWhenText || ''
            });

            // 2) 결재선 (있으면 추가, 없으면 작성자 1행만 표시)
            approvals.forEach(a => {
                const fullDisplayName = getApprovalDisplayName(a);
                const nameOnly = extractPersonName(fullDisplayName) || fullDisplayName || '';
                if (!nameOnly) return;

                const statusRaw = (a.status || a.Status || '').toString();
                const actionRaw = (a.action || a.Action || '').toString();

                let stRaw = statusRaw || actionRaw || 'Pending';
                let when = '';

                if (isDocRecalled) {
                    stRaw = 'Pending';
                    when = '';
                } else {
                    const stUpper = String(stRaw || '').toUpperCase();
                    const actedStates = ['APPROVED', 'APPROVE', 'REJECTED', 'REJECT', 'ONHOLD', 'HOLD'];
                    if (actedStates.includes(stUpper)) {
                        when = a.actedAtText || a.actedAt || a.ActedAtText || a.ActedAt || '';
                    } else {
                        when = '';
                    }
                }

                const stKey = mapStatusKey(stRaw);
                const stDisplay = T(stKey || 'DOC_Status_Pending');

                rows.push({
                    name: nameOnly,
                    statusText: stDisplay,
                    whenText: when
                });
            });

            // 3) 렌더링
            tbody.innerHTML = '';
            rows.forEach(r => {
                const tr = document.createElement('tr');
                tr.innerHTML = `
                    <td>${esc(r.name)}</td>
                    <td>${esc(r.statusText)}</td>
                    <td>${esc(r.whenText)}</td>`;
                tbody.appendChild(tr);
            });
        })();

        // ================== 인쇄/Export ==================
        document.getElementById('btnPrint')?.addEventListener('click', () => {
            window.print();
        });

        document.getElementById('btnExport')?.addEventListener('click', () => {
            if (!docId) return;
            const url = '/Doc/ExportPdf?id=' + encodeURIComponent(docId);
            window.location.href = url;
        });

        // ================== 승인 버튼 처리 ==================
        (function initApproveButtons() {
            const EBC = window.EBCSRF || window.EBCsrf || {};
            const alertHost = document.getElementById('detail-alert');
            if (!alertHost || !docId) return;

            function show(msg, cls) {
                alertHost.innerHTML =
                    `<div class="alert ${cls} py-1 my-1">${msg}</div>`;
            }

            async function call(action) {
                try {
                    const res = await EBC.json('/Doc/ApproveOrHold', {
                        docId: docId,
                        action: action
                    }, 'POST');

                    if (!res || res.ok === false) throw { payload: res };
                    show(T('DOC_Msg_Approve_Success'), 'alert-success');
                    location.reload();
                } catch (e) {
                    const p = e && e.payload;
                    const msgs = p?.messages || [T('DOC_Err_SaveFailed')];
                    show(msgs.join('<br>'), 'alert-danger');
                }
            }

            function bind(selector, action) {
                document.querySelectorAll(selector).forEach(btn => {
                    btn.addEventListener('click', () => {
                        if (btn.disabled) return;
                        call(action);
                    });
                });
            }

            bind('[data-approve]', 'Approve');
            bind('[data-hold]', 'Hold');
            bind('[data-reject]', 'Reject');
        })();

        // ================== 회수 버튼 처리 ==================
        (function initRecallButton() {
            const EBC = window.EBCSRF || window.EBCsrf || {};
            const btnRecall = document.getElementById('btnRecall');
            const alertHost = document.getElementById('detail-alert');

            if (!btnRecall || !docId) return;

            function show(msg, cls) {
                if (!alertHost) return;
                alertHost.innerHTML =
                    `<div class="alert ${cls} py-1 my-1">${msg}</div>`;
            }

            btnRecall.addEventListener('click', async () => {
                if (btnRecall.disabled) return;

                try {
                    const res = await EBC.json('/Doc/ApproveOrHold', {
                        docId: docId,
                        action: 'Recall'
                    }, 'POST');

                    if (!res || res.ok === false) throw { payload: res };

                    show(T('DOC_Msg_Recall_Success') || T('DOC_Msg_Approve_Success'), 'alert-success');
                    location.href = '/Doc/Board';
                } catch (e) {
                    const p = e && e.payload;
                    const msgs = p?.messages || [T('DOC_Err_RequestFailed')];
                    show(msgs.join('<br>'), 'alert-danger');
                }
            });
        })();

        // ================== 인쇄용 테이블 자동 맞춤 ==================
        (function () {
            const xhost = document.getElementById('xhost');
            if (!xhost) return;

            const originalParent = xhost.parentNode;
            const originalNext = xhost.nextSibling;
            const printWrapper = document.createElement('div');
            printWrapper.id = 'print-xhost-wrapper';

            function moveToPrintWrapper() {
                if (xhost.parentNode === printWrapper) return;

                if (!printWrapper.parentNode) {
                    document.body.appendChild(printWrapper);
                }

                printWrapper.appendChild(xhost);
            }

            function restoreFromPrintWrapper() {
                if (!originalParent) return;

                if (originalNext && originalNext.parentNode === originalParent) {
                    originalParent.insertBefore(xhost, originalNext);
                } else {
                    originalParent.appendChild(xhost);
                }

                if (printWrapper.parentNode) {
                    printWrapper.parentNode.removeChild(printWrapper);
                }
            }

            function handleBeforePrint() {
                moveToPrintWrapper();
            }

            function handleAfterPrint() {
                restoreFromPrintWrapper();
            }

            if (window.matchMedia) {
                const mq = window.matchMedia('print');
                mq.addEventListener('change', function (e) {
                    if (e.matches) {
                        handleBeforePrint();
                    } else {
                        handleAfterPrint();
                    }
                });
            }

            window.addEventListener('beforeprint', handleBeforePrint);
            window.addEventListener('afterprint', handleAfterPrint);
        })();
    </script>
}
