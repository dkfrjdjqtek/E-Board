@* 2025.12.29 Changed: 저장 핸들러 중복 실행 위험 제거를 위해 저장 로직은 submitBtn 클릭 핸들러 1벌만 유지하고 SelectedRecipientUserIds 바인딩 유실 방지를 위해 요청 바디에 키를 이중 전송하도록 수정 *@
@* 2025.12.12 Changed: 문서 작성 화면 하단에 조직 멀티 선택 콤보박스 추가 회사 부서 직책이름 3단 트리 사용 *@
@* 2025.12.08 Changed: 메일 파라미터 계산 시 1차 승인권자만 수신자로 사용하고 to cc bcc 중복 주소를 통합하여 전달 *@
@* 2025.11.11 Changed: 포커스 링 단일화 및 활성 그룹 기준 재계산 (비고 영역에 고정되던 문제 수정) *@
@* 2025.11.04 Changed: 메일 전송 요청 body 구성과 CSRF 토큰 적용 저장 응답 처리 보강 기타 로직 변경 없음 *@
@using WebApplication1.Models
@model WebApplication1.Models.DocTLViewModel
@inject Microsoft.Extensions.Localization.IStringLocalizer<SharedResource> S
@{
    ViewData["Title"] = S["DOC_Title_Compose"];
    var templateCode = (string?)ViewBag.TemplateCode
                        ?? (Context?.Request?.Query["templateCode"].ToString() ?? string.Empty);
    var templateTitle = (string?)ViewBag.TemplateTitle ?? string.Empty;
    var descJson = (string?)ViewBag.DescriptorJson ?? "{}";
    var previewJson = (string?)ViewBag.PreviewJson ?? "{}";
}
<style>
    :root {
        --vscroll-w: 0px;
        --eb-group-bg: rgb(240 248 255 / 55%);
        --eb-group-bg-hover: rgb(240 248 255 / 55%);
        --eb-ring-border: #8CB8FF;
        --eb-ring-glow: rgba(140,184,255,.35);
        --eb-ring-w: 2px;
        --eb-ring-pad: 2px;
        --eb-ring-glow-w: 4px;
    }

    @Html.Raw("@keyframes ebBlink{0%{box-shadow:none}50%{box-shadow:0 0 0 3px rgba(215,0,0,.35)}100%{box-shadow:none}}")

    html, body {
        height: 100%;
        overflow: hidden !important;
        background: #fff;
        margin: 0;
    }

    #doc-scroll {
        position: fixed;
        /* 2025.12.15 Changed: Detail 과 동일하게 CSS 변수 기반으로 기본 inset 고정 */
        top: var(--header-h, 0px);
        left: var(--sidebar-w, 0px);
        right: 0;
        bottom: var(--footer-h, 0px);

        overflow-y: auto !important;
        overflow-x: auto !important;
        box-sizing: border-box;
        background: #fff;

        /* 2025.12.15 Changed: 헤더/사이드바 위로 가리지 않도록 레이어 우선순위 상향 */
        z-index: 10000;

        scrollbar-gutter: stable both-edges;
        padding-bottom: 0;
    }

    .doc-unclip {
        overflow: visible !important;
        max-width: none !important;
        transform: none !important;
        will-change: auto !important;
        filter: none !important;
    }

    .page-header {
        display: flex;
        align-items: center;
        gap: 12px;
        padding: 16px;
        margin: 0;
    }
    .page-header h3 { margin: 0; }

    #xlPreview {
        position: relative;
        display: block;
        margin: 0;
        padding: 0;
        overflow: visible;
    }

    #xhost {
        display: block;
        width: auto;
        max-width: none;
        overflow: hidden;
        position: relative;
    }

    .xlfb {
        border-collapse: collapse;
        table-layout: fixed;
        position: relative;
    }

    .xlfb td, .xlfb th {
        box-sizing: border-box;
        position: relative;
    }
    .xlfb thead, .xlfb tbody th { display: none; }

    .xlfb td {
        padding: 0;
        vertical-align: middle;
        overflow: hidden;
        word-break: break-word;
        white-space: pre-wrap;
    }

    .cellc {
        padding: .0rem .45rem;
        font-size: .925rem;
        line-height: 1.2;
        max-height: 100%;
        overflow: hidden;
        display: block;
    }

    .ta-left { text-align: left }
    .ta-center { text-align: center }
    .ta-right { text-align: right }
    .va-top { vertical-align: top }
    .va-middle { vertical-align: middle }
    .va-bottom { vertical-align: bottom }
    .wrap { white-space: pre-line }

    .eb-editable { transition: background-color .12s ease-in-out }
    td.eb-group { background: var(--eb-group-bg) }
    td.eb-group:hover { background: var(--eb-group-bg-hover) }

    .eb-input-date {
        width: 100%;
        border: none;
        outline: none;
        background: transparent;
        font: inherit;
        padding: 0;
        margin: 0;
        height: 1.6em;
    }
    input[type="date"]::-webkit-calendar-picker-indicator { opacity: 0 }
    input[type="date"]::-moz-focus-inner { border: 0 }

    .eb-block {
        position: absolute;
        box-sizing: border-box;
        background: transparent;
        color: inherit;
        outline: none;
        white-space: pre-wrap;
        overflow: hidden;
        scrollbar-width: none;
        pointer-events: none;
        z-index: 2;
        padding-left: 0;
        padding-right: 0;
        user-select: none;
    }

    .eb-group-ring {
        position: absolute;
        pointer-events: none;
        border: var(--eb-ring-w) solid var(--eb-ring-border);
        border-radius: 6px;
        box-shadow: 0 0 0 var(--eb-ring-glow-w) var(--eb-ring-glow);
        z-index: 3;
        display: none;
    }

    .eb-ta {
        position: absolute;
        left: 0; top: 0;
        width: 100%; height: 100%;
        background: transparent;
        border: none; outline: none;
        z-index: 4; pointer-events: auto;
        font: inherit; color: inherit; line-height: inherit;
        padding: .0rem .45rem; margin: 0;
        resize: none; overflow: hidden;
        white-space: pre;
        -webkit-user-modify: read-write-plaintext-only;
    }

    .form-actions {
        margin: 16px;
        padding: 12px 0;
        border-top: 1px solid #e9ecef;
        display: flex;
        gap: 8px;
        max-width: 100%;
    }

    .action-btn { width: 140px; height: 36px; white-space: nowrap; }

    .eb-limit-blink { animation: ebBlink .18s ease-in-out 2 }

    @Html.Raw("@media print{#doc-scroll{overflow:visible;position:static;inset:auto;height:auto;padding:0}.form-actions{display:none}.xlfb{outline:1px solid #000;outline-offset:-1px}td.eb-group{background:transparent!important}.eb-group-ring{display:none!important}}")

    /* 디버그용 간단 모달 */
    .eb-modal-mask {
        position: fixed; inset: 0; background: rgba(0,0,0,.35);
        z-index: 20000; display: flex; align-items: center; justify-content: center;
    }
    .eb-modal {
        background: #fff; width: min(920px,96vw); max-height: 86vh;
        border-radius: 8px; box-shadow: 0 14px 48px rgba(0,0,0,.25);
        display: flex; flex-direction: column;
    }
    .eb-modal header {
        padding: 10px 14px; border-bottom: 1px solid #e5e7eb;
        display: flex; justify-content: space-between; align-items: center
    }
    .eb-modal .body { padding: 0; overflow: auto }
    .eb-modal pre { margin: 0; padding: 12px 14px; font-size: .86rem }
    .eb-modal footer {
        padding: 10px 14px; border-top: 1px solid #e5e7eb;
        display: flex; gap: 8px; justify-content: flex-end
    }

    .btn {
        display: inline-flex; align-items: center; justify-content: center;
        height: 36px; padding: 0 14px; border-radius: 8px;
        border: 1px solid transparent; cursor: pointer;
    }
    .btn-primary { background: #0d6efd; color: #fff }
    .btn-outline { background: #fff; border-color: #cbd5e1; color: #111827 }
</style>

<div id="doc-scroll" data-template-code="@templateCode">
    <div class="page-header">
        <h3>@S["DOC_Title_Compose"]</h3>
        <span class="text-muted">@templateTitle</span>
    </div>
    <div id="doc-alert" class="mb-2" aria-live="polite"></div>

    <form id="doc-form" method="post" asp-controller="Doc" asp-action="Create" novalidate style="max-width:100%">
        <input type="hidden" name="TemplateCode" value="@templateCode" />
        <input type="hidden" name="templateCode" value="@templateCode" />

        <script type="application/json" id="DescriptorJson">@Html.Raw(descJson)</script>
        <script type="application/json" id="PreviewJson">@Html.Raw(previewJson)</script>

        <script>
           window.__RESX = @Html.Raw(System.Text.Json.JsonSerializer.Serialize(new
    {
        DOC_Err_PreviewFailed = S["DOC_Err_PreviewFailed"].Value,
        DOC_Err_SaveFailed = S["DOC_Err_SaveFailed"].Value,
        DOC_Msg_Saved = S["DOC_Msg_Saved"].Value,
        DOC_Val_TemplateRequired = S["DOC_Val_TemplateRequired"].Value,
        DOC_Btn_Cancel = S["DOC_Btn_Cancel"].Value,
        DOC_Submit_Button = S["DOC_Submit_Button"].Value,

        DOC_Err_UploadFailed = S["DOC_Err_UploadFailed"].Value,

        ORG_MS_Placeholder_Search = S["ORG_MS_Placeholder_Search"].Value,
        ORG_MS_Placeholder_Empty  = S["ORG_MS_Placeholder_Empty"].Value,
        ORG_MS_Label_SelectedCount = S["ORG_MS_Label_SelectedCount"].Value,
        ORG_MS_Label_All          = S["ORG_MS_Label_All"].Value,
        ORG_MS_Label_Clear        = S["ORG_MS_Label_Clear"].Value,
                  
        DOC_Attach_Count_None = S["DOC_Attach_Count_None"].Value,
        DOC_Attach_Count_N    = S["DOC_Attach_Count_N"].Value,

        DOC_Debug_Title = S["DOC_Debug_Title"].Value,
        DOC_Debug_Hint = S["DOC_Debug_Hint"].Value,
        DOC_Btn_ContinueSave = S["DOC_Btn_ContinueSave"].Value, 
        _CM_Delete = S["_CM_Delete"].Value

    }));
    window.__tplFromServer = @Html.Raw(System.Text.Json.JsonSerializer.Serialize(templateCode ?? string.Empty));
</script>

        <div id="xlPreview"><div id="xhost"></div></div>

<div class="mt-3 mb-3">
    <label class="form-label">@S["DOC_Label_Attachments"]</label>

    <div class="d-flex align-items-center gap-2 flex-wrap">
        <button type="button" class="btn btn-secondary" id="doc-attach-pick">
            @S["_CM_Select"]
        </button>

        <input id="doc-attachments"
               type="file"
               multiple
               style="display:none" />

        <span class="text-muted" id="doc-attach-count"></span>
    </div>

    <div id="doc-attach-list" class="mt-2"></div>
</div>

        @* === 여기부터: 조직 멀티 선택 콤보박스 추가 영역 === *@
        <div class="mt-3 mb-3">
            <label class="form-label">@S["DOC_Label_Recipients"]</label>
            @{
                var orgNodes = ViewBag.OrgTreeNodes as IEnumerable<OrgTreeNode> ?? Array.Empty<OrgTreeNode>();
            }
            @await Html.PartialAsync(
                "_OrgMultiSelectCombo",
                orgNodes,
                new Microsoft.AspNetCore.Mvc.ViewFeatures.ViewDataDictionary(ViewData)
                {
                    ["ControlId"] = "doc-recipient-select",
                    ["FieldName"] = "SelectedRecipientUserIds"
                })
        </div>
        @* === 조직 멀티 선택 콤보박스 영역 끝 === *@

        <div class="form-actions">
            <button type="button" id="btn-save" class="btn btn-primary action-btn" data-doc-submit>
                @S["DOC_Submit_Button"]
            </button>
            <button type="button" id="btn-cancel" class="btn btn-outline-secondary action-btn">
                @S["DOC_Btn_Cancel"]
            </button>
        </div>
    </form>
</div>

@section Scripts {
<script src="~/js/eb.csrf.js"></script>
<script>
(function () {
    // =====================================================================
    // A안: Create는 JSON만, 첨부는 Create 성공 후 /DocFile/Upload로 업로드입니다.
    // - /DocFile/Upload 선업로드 로직 제거
    // - 첨부 목록은 file input(files) 기반으로만 표시
    // =====================================================================

    /* ===== 공통 유틸 ===== */
    const $ = (q, r = document) => r.querySelector(q);
    const $alert = () => document.getElementById('doc-alert');

    function decodeHtmlEntities(str) {
        if (str == null) return '';
        let s = String(str);
        s = s.replace(/&#x([0-9a-fA-F]+);/g, (_, h) => String.fromCodePoint(parseInt(h, 16)));
        s = s.replace(/&#(\d+);/g, (_, d) => String.fromCodePoint(parseInt(d, 10)));
        s = s.replace(/&lt;/g, '<').replace(/&gt;/g, '>').replace(/&amp;/g, '&')
             .replace(/&quot;/g, '"').replace(/&apos;/g, "'");
        return s;
    }

    const T = (m) => {
        if (m == null) return '';
        if (Array.isArray(m)) return m.map(T).join('\n');
        const s = String(m);
        const mapped = (window.__RESX && Object.prototype.hasOwnProperty.call(window.__RESX, s))
            ? window.__RESX[s]
            : s;
        return decodeHtmlEntities(mapped);
    };

    const info = m => {
        $alert()?.replaceChildren(
            Object.assign(document.createElement('div'),
                { className: 'alert alert-info', textContent: T(m) })
        );
    };
    const ok = m => {
        $alert()?.replaceChildren(
            Object.assign(document.createElement('div'),
                { className: 'alert alert-success', textContent: T(m) })
        );
    };
    const err = m => {
        $alert()?.replaceChildren(
            Object.assign(document.createElement('div'),
                { className: 'alert alert-danger', textContent: T(m || 'DOC_Err_PreviewFailed') })
        );
    };

    /* ===== CSRF ===== */
    async function getCsrf() {
    try {
        const r = await fetch('/Doc/Csrf', { credentials: 'same-origin' });
        if (!r.ok) return { headerName: 'RequestVerificationToken', token: '' };
        return await r.json();
    } catch {
        return { headerName: 'RequestVerificationToken', token: '' };
    }
}

    /* ===== 첨부(선택 목록) ===== */
    const fileInput = document.getElementById('doc-attachments');
    const pickBtn = document.getElementById('doc-attach-pick');

    // 실패 목록(클라이언트/서버 메시지 표시용)
    window.__attachments_failed = Array.isArray(window.__attachments_failed) ? window.__attachments_failed : [];

    function setAttachCount(n) {
    const el = document.getElementById('doc-attach-count');
    if (!el) return;

    const v = Math.max(0, Number(n || 0) || 0);

    // 리소스 키가 없으면 화면에 키 문자열이 그대로 노출될 수 있으므로 안전 폴백 처리
    const noneText = (window.__RESX && typeof window.__RESX['DOC_Attach_Count_None'] === 'string')
        ? window.__RESX['DOC_Attach_Count_None']
        : '';

    const nTextTmpl = (window.__RESX && typeof window.__RESX['DOC_Attach_Count_N'] === 'string')
        ? window.__RESX['DOC_Attach_Count_N']
        : '';

    if (v === 0) {
        el.textContent = noneText || '';
        return;
    }

    if (nTextTmpl && nTextTmpl.includes('{0}')) {
        el.textContent = nTextTmpl.replace('{0}', String(v));
        return;
    }

    // 템플릿이 없으면 숫자만 표시(키 노출 방지)
    el.textContent = String(v);
}

    function normStr(v) { return String(v ?? '').trim(); }

    function sigOfFile(f) {
    const name = String(f?.name || '').trim().toLowerCase();
    const size = Number(f?.size || 0) || 0;
    return name + '|' + size;
}
function dedupeFilesKeepFirst(files) {
    const out = [];
    const seen = new Set();
    for (const f of (files || [])) {
        if (!f) continue;
        const sig = sigOfFile(f);
        if (!sig) continue;
        if (seen.has(sig)) continue;
        seen.add(sig);
        out.push(f);
    }
    return out;
}

    function setFileInputFiles(inputEl, filesArr) {
        try {
            const dt = new DataTransfer();
            for (const f of (filesArr || [])) dt.items.add(f);
            inputEl.files = dt.files;
            return true;
        } catch {
            return false;
        }
    }

    function removePickedFileBySig(sig) {
        const inp = document.getElementById('doc-attachments');
        if (!inp) return false;

        const cur = Array.from(inp.files || []);
        if (!cur.length) return false;

        // sigOfFile(f) = name|size 기준(이미 당신 코드에 있음)
        const next = [];
        let removed = false;

        for (const f of cur) {
            const s = sigOfFile(f);
            if (!removed && s === sig) { removed = true; continue; }
            next.push(f);
        }

        if (!removed) return false;
        return setFileInputFiles(inp, next);
    }

    function renderAttachListFromInput() {
        const box = document.getElementById('doc-attach-list');
        if (!box) return;

        const fileInput = document.getElementById('doc-attachments');
        const pickedRaw = Array.from(fileInput?.files || []);
        const picked = dedupeFilesKeepFirst(pickedRaw);

        const failedArr = Array.isArray(window.__attachments_failed) ? window.__attachments_failed : [];

        if (typeof setAttachCount === 'function') setAttachCount(picked.length + failedArr.length);

        box.innerHTML = '';
        if (!picked.length && !failedArr.length) return;

        const wrap = document.createElement('div');
        wrap.style.display = 'flex';
        wrap.style.flexDirection = 'column';
        wrap.style.gap = '6px';

        for (const f of picked) {
            const row = document.createElement('div');
            row.style.display = 'flex';
            row.style.alignItems = 'center';
            row.style.gap = '8px';
            row.style.maxWidth = '100%';

            const text = document.createElement('span');
            text.style.flex = '1 1 auto';
            text.style.minWidth = '0';
            text.style.overflow = 'hidden';
            text.style.textOverflow = 'ellipsis';
            text.style.whiteSpace = 'nowrap';
            text.textContent = `${f.name} (${Number(f.size || 0) || 0})`;

            // ✅ 삭제 버튼 추가
            const delBtn = document.createElement('button');
            delBtn.type = 'button';
            delBtn.className = 'btn btn-outline-secondary';
            delBtn.style.height = '28px';
            delBtn.style.padding = '0 10px';
            delBtn.textContent = (typeof T === 'function') ? T('_CM_Delete') : '_CM_Delete';

            const sig = sigOfFile(f);
            delBtn.addEventListener('click', (e) => {
                e.preventDefault();
                e.stopPropagation();

                // FileList 재구성으로 삭제
                const okRemove = removePickedFileBySig(sig);
                if (okRemove) {
                    // 실패 목록은 그대로 두고, 화면만 재렌더
                    renderAttachListFromInput();
                }
            });

            row.appendChild(text);
            row.appendChild(delBtn);
            wrap.appendChild(row);
        }

        // (failedArr 렌더는 기존 그대로 유지)
        for (const ff of failedArr) {
            const row = document.createElement('div');
            row.style.display = 'flex';
            row.style.alignItems = 'center';
            row.style.gap = '8px';
            row.style.maxWidth = '100%';
            row.style.opacity = '0.75';

            const text = document.createElement('span');
            text.style.flex = '1 1 auto';
            text.style.minWidth = '0';
            text.style.overflow = 'hidden';
            text.style.textOverflow = 'ellipsis';
            text.style.whiteSpace = 'nowrap';

            const errKey = (ff && ff.error) ? String(ff.error) : 'DOC_Err_UploadFailed';
            const nm = (typeof normStr === 'function') ? normStr(ff.name) : String(ff?.name || '');
            text.textContent = `${nm} (${Number(ff.size || 0) || 0}) • ${typeof T === 'function' ? T(errKey) : errKey}`;

            row.appendChild(text);
            wrap.appendChild(row);
        }

        box.appendChild(wrap);
    }

    window.__attach_prev_files = Array.isArray(window.__attach_prev_files) ? window.__attach_prev_files : [];

    pickBtn?.addEventListener('click', (e) => {
        e.preventDefault();
        e.stopPropagation();
        if (!fileInput) return;

        // ✅ 기존 선택 파일을 캐시(사용자가 새로 선택해도 기본 동작으로 덮어써지므로, change에서 병합할 것)
        try {
            const cur = Array.from(fileInput.files || []);
            window.__attach_prev_files = dedupeFilesKeepFirst(cur);
        } catch {
            window.__attach_prev_files = [];
        }

        try { fileInput.click(); } catch { }
    });

    fileInput?.addEventListener('change', () => {
        // 정책 유지: 업로드 실패 목록은 새 선택 시 초기화
        window.__attachments_failed = [];

        const prev = Array.isArray(window.__attach_prev_files) ? window.__attach_prev_files : [];
        const now = Array.from(fileInput?.files || []);

        // ✅ 병합 + 중복 제거(이름|사이즈 시그니처 기준, 기존 dedupe 사용)
        const merged = dedupeFilesKeepFirst([ ...prev, ...now ]);

        // ✅ 실제 input.files 를 병합 결과로 재구성(DataTransfer 사용)
        if (typeof setFileInputFiles === 'function') {
            setFileInputFiles(fileInput, merged);
        }

        // 캐시 정리(다음 클릭 전까지는 불필요)
        window.__attach_prev_files = [];

        renderAttachListFromInput();
    });

    /* ===== 레이아웃 고정 ===== */
    function escapeFixedTraps(el, maxHops = 10, maxApply = 4) {
        let n = el.parentElement, h = 0, a = 0;
        while (n && h < maxHops && a < maxApply) {
            const cs = getComputedStyle(n);
            const hasTrap =
                (cs.transform && cs.transform !== 'none') ||
                (cs.willChange && cs.willChange.includes('transform')) ||
                (cs.filter && cs.filter !== 'none') ||
                (cs.contain && cs.contain !== 'none');
            const clips =
                /(auto|scroll|hidden|clip)/.test(cs.overflowX) ||
                /(auto|scroll|hidden|clip)/.test(cs.overflowY);
            if (hasTrap || clips) { n.classList.add('doc-unclip'); a++; }
            n = n.parentElement; h++;
        }
    }

    function computeInsets() {
        const vw = Math.max(320, innerWidth), vh = Math.max(320, innerHeight);

        const rs = getComputedStyle(document.documentElement);
        let top = parseInt(rs.getPropertyValue('--header-h')) || 0;
        let left = parseInt(rs.getPropertyValue('--sidebar-w')) || 0;
        let right = 0;
        let bottom = parseInt(rs.getPropertyValue('--footer-h')) || 0;

        const hdr = $('[data-app-header]');
        const sdr = $('[data-app-sidebar]');
        const ftr = $('footer,[data-app-footer]');

        if (hdr) {
            const r = hdr.getBoundingClientRect();
            if (r.height > 0) top = Math.max(top, Math.round(r.bottom));
        }
        if (sdr) {
            const r = sdr.getBoundingClientRect();
            if (r.width > 0 && r.left <= 1) left = Math.max(left, Math.round(r.right));
        }
        if (ftr) {
            const r = ftr.getBoundingClientRect();
            if (r.height > 0) bottom = Math.max(bottom, Math.round(vh - r.top));
        }

        const sdr2 = document.querySelector('aside,.sidebar,[class*="sidebar"],[class*="SideBar"]');
        if (sdr2) {
            const r = sdr2.getBoundingClientRect();
            if (r.width > 0 && r.left <= 1) left = Math.max(left, Math.round(r.right));
        }

        top = Math.min(top, Math.floor(vh * 0.5));
        left = Math.min(left, Math.floor(vw * 0.6));
        right = Math.min(right, Math.floor(vw * 0.4));
        bottom = Math.min(bottom, Math.floor(vh * 0.5));
        return { top, left, right, bottom };
    }

    function placeContainer() {
        const host = document.getElementById('doc-scroll');
        const { top, left, right, bottom } = computeInsets();
        host.style.top = top + 'px';
        host.style.left = left + 'px';
        host.style.right = right + 'px';
        host.style.bottom = bottom + 'px';
        host.style.setProperty('overflow-x', 'auto', 'important');
        host.style.setProperty('overflow-y', 'auto', 'important');

        const vInner = host.offsetWidth - host.clientWidth;
        host.style.paddingInlineEnd = (vInner > 0 ? vInner + 'px' : '0');
    }

    /* ===== 프리뷰/스타일 보조 ===== */
    function readJson(id) {
        try {
            const el = document.getElementById(id);
            if (!el) return {};
            const raw = el.textContent || '';
            const v = JSON.parse(raw);
            return typeof v === 'string' ? JSON.parse(v) : v;
        } catch { return {}; }
    }

    const descriptor = readJson('DescriptorJson');
    const preview = readJson('PreviewJson');
    window.descriptor = descriptor;

    const excelColWidthToPx = W => {
        const w = Number(W);
        if (!isFinite(w) || w < 0) return 0;
        return Math.max(0, Math.floor(w * 7 + 5));
    };

    const ptToPx = pt => ((Number(pt) || 0) * 96 / 72);

    function hasVisibleStyle(st) {
        if (!st) return false;
        if (st.fill && st.fill.bg) return true;
        if (st.font && (st.font.bold || st.font.italic || st.font.underline || st.font.size || st.font.name)) return true;
        const b = st.border || {};
        return !!((b.l && b.l !== 'None') || (b.r && b.r !== 'None') || (b.t && b.t !== 'None') || (b.b && b.b !== 'None'));
    }

    function a1ToRC(a1) {
        if (!a1) return null;
        const m = String(a1).toUpperCase().match(/^([A-Z]+)(\d+)$/);
        if (!m) return null;
        const letters = m[1];
        const row = parseInt(m[2], 10);
        let col = 0;
        for (let i = 0; i < letters.length; i++) {
            col = col * 26 + (letters.charCodeAt(i) - 64);
        }
        return { r: row, c: col };
    }

    const posToMeta = new Map();
    (Array.isArray(descriptor?.inputs) ? descriptor.inputs : []).forEach(f => {
        if (!f?.key) return;
        const rc = a1ToRC(f.a1 || '');
        if (!rc) return;
        posToMeta.set(`${rc.r},${rc.c}`, {
            key: String(f.key),
            type: String(f.type || 'Text'),
            rc
        });
    });

    const payloadInputs = {};
    window.payloadInputs = payloadInputs;

    function applyStyleToCell(td, cell, st) {
        if (!st || typeof st !== 'object') return;

        if (st.font) {
            if (st.font.name) cell.style.fontFamily = st.font.name;
            if (st.font.size) cell.style.fontSize = ptToPx(st.font.size) + 'px';
            if (st.font.bold) cell.style.fontWeight = '700';
            if (st.font.italic) cell.style.fontStyle = 'italic';
            if (st.font.underline) cell.style.textDecoration = 'underline';
        }

        if (st.align) {
            const h = String(st.align.h || '').toLowerCase();
            cell.classList.remove('ta-left', 'ta-center', 'ta-right');
            if (h === 'center') cell.classList.add('ta-center');
            else if (h === 'right') cell.classList.add('ta-right');
            else cell.classList.add('ta-left');

            const v = String(st.align.v || '').toLowerCase();
            td.classList.remove('va-top', 'va-middle', 'va-bottom');
            if (v === 'top') td.classList.add('va-top');
            else if (v === 'center' || v === 'middle') td.classList.add('va-middle');
            else td.classList.add('va-bottom');

            if (st.align.wrap) cell.classList.add('wrap');
        }

        const cssOf = s => {
            s = String(s || '').toLowerCase();
            if (!s || s === 'none') return { w: 0, sty: 'none' };
            if (s.includes('double')) return { w: 3, sty: 'double' };
            if (s.includes('mediumdashdotdot') || s.includes('mediumdashdot') || s.includes('mediumdashed')) return { w: 2, sty: 'dashed' };
            if (s.includes('dashdotdot') || s.includes('dashdot') || s.includes('dashed')) return { w: 1, sty: 'dashed' };
            if (s.includes('dotted') || s.includes('hair')) return { w: 1, sty: 'dotted' };
            if (s.includes('thick')) return { w: 3, sty: 'solid' };
            if (s.includes('medium')) return { w: 2, sty: 'solid' };
            return { w: 1, sty: 'solid' };
        };

        const color = '#000';
        if (st.border) {
            const L = cssOf(st.border.l),
                R = cssOf(st.border.r),
                T = cssOf(st.border.t),
                B = cssOf(st.border.b);
            td.style.borderLeft = L.w ? `${L.w}px ${L.sty} ${color}` : 'none';
            td.style.borderRight = R.w ? `${R.w}px ${R.sty} ${color}` : 'none';
            td.style.borderTop = T.w ? `${T.w}px ${T.sty} ${color}` : 'none';
            td.style.borderBottom = B.w ? `${B.w}px ${B.sty} ${color}` : 'none';
        }
    }

    function measureEffectiveContentWidth(tbl) {
        if (!tbl) return 0;
        const baseLeft = tbl.getBoundingClientRect().left;
        let maxRight = 0;

        for (const td of tbl.querySelectorAll('td')) {
            const cs = getComputedStyle(td);
            const hasBorder =
                ((parseFloat(cs.borderLeftWidth) || 0) > 0) ||
                ((parseFloat(cs.borderRightWidth) || 0) > 0) ||
                ((parseFloat(cs.borderTopWidth) || 0) > 0) ||
                ((parseFloat(cs.borderBottomWidth) || 0) > 0);
            const hasText = (td.textContent || '').trim().length > 0;
            const isEditable = td.classList.contains('eb-editable');

            if (hasBorder || hasText || isEditable) {
                const r = td.getBoundingClientRect().right;
                if (r > maxRight) maxRight = r;
            }
        }

        const eff = Math.ceil(maxRight - baseLeft);
        return (isFinite(eff) && eff > 0) ? eff : 0;
    }

    function computeFinalDocW() {
        const tbl = document.querySelector('#xhost table');
        if (!tbl) return 0;
        const eff = Math.max(1,
            Number(window.__DOC_EFFW__) || 0,
            measureEffectiveContentWidth(tbl) | 0
        );
        const tblW = Math.max(1,
            Number(window.__DOC_TOTALW__) || 0,
            tbl.scrollWidth | 0,
            tbl.offsetWidth | 0
        );
        return Math.min(eff, tblW);
    }

    function applyFinalWidth() {
        const w = computeFinalDocW();
        const xhost = document.getElementById('xhost');
        if (xhost) xhost.style.width = (w > 0 ? w.toFixed(2) : '1') + 'px';
        window.__DOC_FINALW__ = w;
    }

    let HMAX = 0;
    function updateClampBounds() {
        const sc = document.getElementById('doc-scroll');
        const finalW = computeFinalDocW();
        if (!sc || !finalW) return;
        const viewW = sc.clientWidth | 0;
        const EPS = 6;
        HMAX = Math.max(0, (finalW - viewW - EPS) | 0);
        if (sc.scrollLeft > HMAX) sc.scrollLeft = HMAX;
        if (sc.scrollLeft < 0) sc.scrollLeft = 0;
        window.__DOC_FINALW__ = finalW;
    }

    /* ===== 입력 그룹/포커스 링 유틸 ===== */
    const cellDivByKey = k =>
        document.querySelector(`#xhost td[data-key="${CSS.escape(k)}"] .cellc`);
    const tdByKey = k =>
        document.querySelector(`#xhost td[data-key="${CSS.escape(k)}"]`);

    function getRingHost() { return document.getElementById('xhost'); }

    function getOrCreateRing() {
        const host = getRingHost();
        if (!host) return null;
        let el = host.querySelector(':scope > .eb-group-ring');
        if (!el) {
            el = document.createElement('div');
            el.className = 'eb-group-ring';
            host.appendChild(el);
        }
        return el;
    }

    function showRingForRect(rect) {
        const ring = getOrCreateRing();
        if (!ring || !rect) return;
        const pad = parseFloat(
            getComputedStyle(document.documentElement).getPropertyValue('--eb-ring-pad')
        ) || 2;

        ring.style.left = Math.round(rect.left - pad) + 'px';
        ring.style.top = Math.round(rect.top - pad) + 'px';
        ring.style.width = Math.max(0, Math.round(rect.width + pad * 2)) + 'px';
        ring.style.height = Math.max(0, Math.round(rect.height + pad * 2)) + 'px';
        ring.style.display = 'block';
    }

    function hideRingIfIdle() {
        const host = getRingHost();
        if (!host) return;
        const hasActiveBlock = host.querySelector('.eb-block[data-active="1"]');
        const hasActiveInput = host.querySelector('td.eb-group input:focus, td.eb-group textarea:focus');
        if (!hasActiveBlock && !hasActiveInput) {
            const ring = getOrCreateRing();
            if (ring) ring.style.display = 'none';
        }
    }

    function buildAutoFlowGroups(inputs) {
        const by = new Map();
        (inputs || []).forEach(f => {
            if (!f?.key || !f?.a1) return;
            const type = String(f.type || 'Text').toLowerCase();
            if (type !== 'text') return;
            const m = String(f.key).match(/^(.*)_(\d+)$/);
            const rc = a1ToRC(f.a1);
            if (!rc) return;
            const base = m ? m[1] : f.key;
            const sig = `${base}:${rc.c}`;
            if (!by.has(sig)) by.set(sig, []);
            by.get(sig).push({ key: f.key, rc });
        });

        const groups = [];
        by.forEach(list => {
            list.sort((a, b) => a.rc.r - b.rc.r);
            let run = [];
            for (let i = 0; i < list.length; i++) {
                if (i === 0) { run = [list[i]]; continue; }
                const prev = list[i - 1].rc.r;
                const cur = list[i].rc.r;
                if (cur === prev + 1) run.push(list[i]);
                else {
                    if (run.length) groups.push({ keys: run.map(x => x.key) });
                    run = [list[i]];
                }
            }
            if (run.length) groups.push({ keys: run.map(x => x.key) });
        });
        return groups;
    }

    function colorizeInputGroups() {
        const groups = buildAutoFlowGroups(Array.isArray(descriptor?.inputs) ? descriptor.inputs : []);

        groups.forEach(g => {
            for (const k of g.keys) {
                const td = tdByKey(k);
                if (!td) continue;
                td.classList.add('eb-group');
            }
        });

        document.querySelectorAll('#xhost td[data-key]').forEach(td => {
            td.classList.add('eb-group');
            const input = td.querySelector('input,select,textarea');
            if (!input) return;

            input.addEventListener('focus', () => {
                const hostRect = getRingHost()?.getBoundingClientRect();
                const rc = td.getBoundingClientRect();
                if (!hostRect) return;

                const rect = {
                    left: Math.round(rc.left - hostRect.left),
                    top: Math.round(rc.top - hostRect.top),
                    width: Math.max(0, Math.round(rc.width)),
                    height: Math.max(0, Math.round(rc.height))
                };

                td.dataset.active = '1';
                showRingForRect(rect);
            }, true);

            input.addEventListener('blur', () => {
                delete td.dataset.active;
                hideRingIfIdle();
            }, true);
        });
    }

    /* ===== 텍스트 폭 클램프 유틸 ===== */
    const __eb_canvas = document.createElement('canvas');
    const __eb_ctx = __eb_canvas.getContext('2d');

    function __eb_getAvailWidth(ta) {
        const cs = getComputedStyle(ta);
        return ta.clientWidth - (parseFloat(cs.paddingLeft) || 0) - (parseFloat(cs.paddingRight) || 0);
    }

    function __eb_ctxFontFrom(ta) {
        const cs = getComputedStyle(ta);
        return `${cs.fontStyle} ${cs.fontVariant} ${cs.fontWeight} ${cs.fontSize} ${cs.fontFamily}`;
    }

    function __eb_normalizeClamp(ta, maxLines) {
        const norm = s => String(s || '').replace(/\r\n?/g, '\n');
        const original = norm(ta.value);
        const availW = __eb_getAvailWidth(ta);
        __eb_ctx.font = __eb_ctxFontFrom(ta);

        const tokens = [];
        for (let i = 0; i < original.length;) {
            const ch = original[i];
            if (ch === '\n') { tokens.push('\n'); i++; continue; }
            if (ch === ' ') {
                let j = i + 1;
                while (j < original.length && original[j] === ' ') j++;
                tokens.push(original.slice(i, j));
                i = j; continue;
            }
            let j = i + 1;
            while (j < original.length && original[j] !== '\n' && original[j] !== ' ') j++;
            tokens.push(original.slice(i, j));
            i = j;
        }

        const lines = [''];
        let li = 0;

        function put(tok) {
            if (tok === '\n') {
                if (lines.length < maxLines) {
                    lines.push('');
                    li++;
                    return true;
                }
                return false;
            }
            const cand = (lines[li] || '') + tok;
            if (__eb_ctx.measureText(cand).width <= availW) {
                lines[li] = cand; return true;
            }
            if (lines.length >= maxLines) return false;
            lines.push(''); li++;
            if (__eb_ctx.measureText(tok).width <= availW) {
                lines[li] = tok; return true;
            }
            let acc = '';
            for (const c of tok) {
                const t = acc + c;
                if (__eb_ctx.measureText(t).width > availW) {
                    if (lines.length >= maxLines) break;
                    lines[li] = acc;
                    lines.push(''); li++;
                    acc = __eb_ctx.measureText(c).width > availW ? '' : c;
                } else {
                    acc = t;
                }
            }
            if (acc) lines[li] = acc;
            return lines.length <= maxLines;
        }

        for (const t of tokens) {
            if (!put(t)) break;
        }

        const out = (
            lines.length >= maxLines
                ? lines.slice(0, maxLines)
                : lines.concat(Array(maxLines - lines.length).fill(''))
        ).join('\n');

        const pos = Math.min(out.length, (ta.selectionStart ?? out.length));
        ta.value = out;
        ta.setSelectionRange(pos, pos);
    }

    function __eb_bindBeforeInputWidthClamp(ta, maxLines) {
        const norm = v => String(v || '').replace(/\r\n?/g, '\n');
        const blink = el => {
            el.classList.add('eb-limit-blink');
            setTimeout(() => el.classList.remove('eb-limit-blink'), 260);
        };

        function tailHasFree(fromLineExclusive) {
            const arr = norm(ta.value).split('\n');
            for (let i = fromLineExclusive + 1; i < maxLines; i++) {
                const s = (arr[i] ?? '');
                if (s.trim().length === 0) return true;
            }
            return false;
        }

        function caretMeta() {
            const raw = ta.value;
            const s = ta.selectionStart ?? 0;
            const e = ta.selectionEnd ?? s;
            const up = norm(raw.slice(0, s));
            const curLine = (up.match(/\n/g) || []).length;
            const colInLine = up.length - (up.lastIndexOf('\n') + 1);
            return { raw, s, e, curLine, colInLine };
        }

        const canEnterAt = lineIdx => (lineIdx < maxLines - 1) && tailHasFree(lineIdx);

        if (ta.dataset.ebBind === '1') return;
        ta.dataset.ebBind = '1';

        ta.addEventListener('beforeinput', ev => {
            const type = ev.inputType || '';
            if (type.startsWith('delete')) return;
            if (type === 'insertFromPaste') return;

            const isEnter = (type === 'insertParagraph' || type === 'insertLineBreak');
            const data = isEnter ? '\n' : (ev.data || '');
            if (!data && !/insert|composition/i.test(type)) return;

            const { raw, s, e, curLine, colInLine } = caretMeta();

            if (isEnter) {
                ev.preventDefault();
                if (!canEnterAt(curLine)) { blink(ta); return; }
                ta.value = raw.slice(0, s) + '\n' + raw.slice(e);
                const pos = s + 1;
                ta.setSelectionRange(pos, pos);
                queueMicrotask(() => __eb_normalizeClamp(ta, maxLines));
                return;
            }

            const lines = norm(raw).split('\n');
            const curLineText = lines[curLine] ?? '';
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            const cs = getComputedStyle(ta);
            ctx.font = `${cs.fontStyle} ${cs.fontVariant} ${cs.fontWeight} ${cs.fontSize} ${cs.fontFamily}`;

            const candidate =
                curLineText.slice(0, colInLine) +
                (ev.data || '') +
                curLineText.slice(colInLine + (e - s));

            const tooWide = ctx.measureText(candidate).width > __eb_getAvailWidth(ta);

            if (tooWide) {
                if (!canEnterAt(curLine)) { ev.preventDefault(); blink(ta); return; }
                ev.preventDefault();
                ta.value = raw.slice(0, s) + '\n' + (ev.data || '') + raw.slice(e);
                const pos = s + 1 + (ev.data || '').length;
                ta.setSelectionRange(pos, pos);
                queueMicrotask(() => __eb_normalizeClamp(ta, maxLines));
                return;
            }

            const simulated = norm(raw.slice(0, s) + (ev.data || '') + raw.slice(e));
            const lineCount = (simulated.match(/\n/g) || []).length + 1;
            if (lineCount > maxLines) {
                ev.preventDefault();
                blink(ta);
            }
        }, true);

        ta.addEventListener('keydown', e => {
            if (e.key !== 'Enter') return;
            const raw = ta.value;
            const s = ta.selectionStart ?? 0;
            const up = raw.slice(0, s).replace(/\r\n?/g, '\n');
            const curLine = (up.match(/\n/g) || []).length;
            if (!canEnterAt(curLine)) {
                e.preventDefault();
                blink(ta);
            }
        }, true);
    }

    const TAB_SIZE = 4;
    const TAB_SPACES = ' '.repeat(TAB_SIZE);

    function __eb_insertSmart_fromStart(ta, text, maxLines) {
        const norm = s => String(s || '').replace(/\r\n?/g, '\n');
        const raw = norm(ta.value);
        const s = ta.selectionStart ?? 0;
        const startLine = (norm(raw.slice(0, s)).match(/\n/g) || []).length;
        const head = raw.split('\n').slice(0, startLine);
        ta.value = head.join('\n');
        if (ta.value && !ta.value.endsWith('\n')) ta.value += '\n';
        ta.setSelectionRange(ta.value.length, ta.value.length);

        text = norm(text).replace(/\t/g, TAB_SPACES);

        const availW = __eb_getAvailWidth(ta);
        __eb_ctx.font = __eb_ctxFontFrom(ta);

        const tokens = [];
        for (let i = 0; i < text.length;) {
            const ch = text[i];
            if (ch === '\n') { tokens.push('\n'); i++; continue; }
            if (ch === ' ') {
                let j = i + 1;
                while (j < text.length && text[j] === ' ') j++;
                tokens.push(text.slice(i, j));
                i = j; continue;
            }
            let j = i + 1;
            while (j < text.length && text[j] !== '\n' && text[j] !== ' ') j++;
            tokens.push(text.slice(i, j));
            i = j;
        }

        const lines = [''];
        let li = 0;

        function push(tok) {
            if (tok === '\n') {
                if (lines.length >= maxLines) return false;
                lines.push(''); li++; return true;
            }
            const cand = (lines[li] || '') + tok;
            if (__eb_ctx.measureText(cand).width <= availW) {
                lines[li] = cand; return true;
            }
            if (lines.length >= maxLines) return false;
            lines.push(''); li++;
            if (__eb_ctx.measureText(tok).width <= availW) {
                lines[li] = tok; return true;
            }
            for (const c of tok) {
                const t = (lines[li] || '') + c;
                if (__eb_ctx.measureText(t).width > availW) {
                    if (lines.length >= maxLines) return false;
                    lines.push(''); li++;
                    if (__eb_ctx.measureText(c).width > availW) return false;
                    lines[li] = c;
                } else {
                    lines[li] = t;
                }
            }
            return true;
        }

        for (const t of tokens) {
            if (!push(t)) break;
        }

        const body = lines.slice(0, maxLines).join('\n');
        const glue = (ta.value && body) ? '\n' : '';
        ta.value = ta.value + glue + body;
        __eb_normalizeClamp(ta, maxLines);
    }

    function bindTabAsSpaces(ta) {
        ta.addEventListener('keydown', (e) => {
            if (e.key !== 'Tab') return;
            e.preventDefault();
            const s = ta.selectionStart || 0;
            const selEnd = ta.selectionEnd || s;
            const before = ta.value.slice(0, s);
            const after = ta.value.slice(selEnd);
            ta.value = before + ' '.repeat(4) + after;
            const pos = s + 4;
            ta.setSelectionRange(pos, pos);
            ta.dispatchEvent(new Event('input'));
        });
    }

    function yToLineIdx(relY, lineH, maxLines) {
        const h = Math.max(1, lineH | 0);
        const idx = Math.floor(Math.max(0, Math.min(relY, maxLines * h - 1)) / h);
        return Math.max(0, Math.min(maxLines - 1, idx));
    }

    function moveCaretToLineEnd(ta, lineIdx) {
        const lines = ta.value.replace(/\r\n?/g, '\n').split('\n');
        const i = Math.max(0, Math.min(lineIdx, Math.max(0, lines.length - 1)));
        let pos = 0;
        for (let k = 0; k < i; k++) pos += (lines[k] || '').length + 1;
        pos += (lines[i] || '').length;
        ta.setSelectionRange(pos, pos);
    }

    /* ===== 오버레이 그룹 ===== */
    let blocks = [];

    function copyStyleFromFirstCell(el, fc) {
        const td = fc.closest('td');
        const cs = getComputedStyle(fc);
        const rowPx = parseFloat(td?.dataset.rowpx || cs.lineHeight) || 16;
        el.style.lineHeight = rowPx + 'px';
        el.style.fontFamily = cs.fontFamily;
        el.style.fontSize = cs.fontSize;
        el.style.fontWeight = cs.fontWeight;
        el.style.fontStyle = cs.fontStyle;
        el.style.letterSpacing = cs.letterSpacing;
        el.style.wordSpacing = cs.wordSpacing;
        el.style.textAlign = cs.textAlign;
        el.style.paddingTop = '0px';
        el.style.paddingBottom = '0px';
        el.style.paddingLeft = cs.paddingLeft;
        el.style.paddingRight = cs.paddingRight;
    }

    function blockRectOfKeys(keys) {
        const tds = keys.map(tdByKey).filter(Boolean);
        if (!tds.length) return null;
        const host = document.getElementById('xhost').getBoundingClientRect();
        let l = Infinity, t = Infinity, r = -Infinity, b = -Infinity;
        for (const td of tds) {
            const rc = td.getBoundingClientRect();
            l = Math.min(l, rc.left);
            t = Math.min(t, rc.top);
            r = Math.max(r, rc.right);
            b = Math.max(b, rc.bottom + 1);
        }
        const left = Math.floor(l - host.left);
        const top = Math.floor(t - host.top);
        const right = Math.ceil(r - host.left);
        const bottom = Math.ceil(b - host.top);
        return { left, top, width: Math.max(0, right - left), height: Math.max(0, bottom - top) };
    }

    function clampToTable(rect) {
        const finalW = Number(window.__DOC_FINALW__) || computeFinalDocW();
        const left = Math.max(0, Math.min(rect.left, finalW));
        const right = Math.max(left, Math.min(rect.left + rect.width, finalW));
        return { left, top: rect.top, width: (right - left), height: rect.height };
    }

    function createGroupsWithEditorOverlay() {
        const groups = (function (inputs) {
            const by = new Map();
            (inputs || []).forEach(f => {
                if (!f?.key || !f?.a1) return;
                const type = String(f.type || 'Text').toLowerCase();
                if (type !== 'text') return;
                const m = String(f.key).match(/^(.*)_(\d+)$/);
                const rc = a1ToRC(f.a1);
                if (!rc) return;
                const base = m ? m[1] : f.key;
                const sig = `${base}:${rc.c}`;
                if (!by.has(sig)) by.set(sig, []);
                by.get(sig).push({ key: f.key, rc });
            });

            const gs = [];
            by.forEach(list => {
                list.sort((a, b) => a.rc.r - b.rc.r);
                let run = [];
                for (let i = 0; i < list.length; i++) {
                    if (i === 0) { run = [list[i]]; continue; }
                    const prev = list[i - 1].rc.r;
                    const cur = list[i].rc.r;
                    if (cur === prev + 1) run.push(list[i]);
                    else {
                        if (run.length) gs.push({ keys: run.map(x => x.key) });
                        run = [list[i]];
                    }
                }
                if (run.length) gs.push({ keys: run.map(x => x.key) });
            });
            return gs;
        })(Array.isArray(descriptor?.inputs) ? descriptor.inputs : []);

        blocks.forEach(b => { b.block?.remove(); b.ta?.remove(); });
        blocks = [];

        const host = document.getElementById('xhost');

        for (const g of groups) {
            const keys = g.keys.filter(k => !!tdByKey(k));
            if (!keys.length) continue;

            const firstCell = cellDivByKey(keys[0]);
            if (!firstCell) continue;

            const initLines = keys.map(k => (cellDivByKey(k)?.textContent || ''));

            keys.forEach(k => {
                const c = cellDivByKey(k);
                if (c) c.textContent = '';
            });

            const block = document.createElement('div');
            block.className = 'eb-block';
            block.setAttribute('tabindex', '-1');

            const ta = document.createElement('textarea');
            ta.className = 'eb-ta';
            ta.setAttribute('rows', String(keys.length));
            ta.setAttribute('wrap', 'off');

            copyStyleFromFirstCell(block, firstCell);
            copyStyleFromFirstCell(ta, firstCell);

            const placeRect = () => {
                const r = blockRectOfKeys(keys) || { left: 0, top: 0, width: 0, height: 0 };
                const rect = clampToTable({
                    left: Math.floor(r.left),
                    top: Math.floor(r.top),
                    width: Math.ceil(r.width),
                    height: Math.ceil(r.height + 2)
                });

                block.style.left = rect.left + 'px';
                block.style.top = rect.top + 'px';
                block.style.width = rect.width + 'px';
                block.style.height = rect.height + 'px';

                ta.style.left = rect.left + 'px';
                ta.style.top = rect.top + 'px';
                ta.style.width = rect.width + 'px';
                ta.style.height = rect.height + 'px';
            };

            placeRect();

            ta.value = initLines.some(t => t && t.length) ? initLines.join('\n') : '';

            const lineH = parseFloat(getComputedStyle(ta).lineHeight) || 16;
            __eb_bindBeforeInputWidthClamp(ta, keys.length);

            function syncPayload() {
                let vis = ta.value.replace(/\r\n?/g, '\n').split('\n');
                if (vis.length < keys.length) vis = vis.concat(Array(keys.length - vis.length).fill(''));
                vis = vis.slice(0, keys.length);
                for (let i = 0; i < keys.length; i++) {
                    payloadInputs[keys[i]] = vis[i] ?? '';
                }
            }

            syncPayload();

            ta.addEventListener('paste', (e) => {
                e.preventDefault();
                const text = (e.clipboardData?.getData('text/plain') || '').replace(/\u200B/g, '');
                __eb_insertSmart_fromStart(ta, text, keys.length);
                __eb_normalizeClamp(ta, keys.length);
                syncPayload();
            });

            bindTabAsSpaces(ta);

            ta.addEventListener('input', () => {
                __eb_normalizeClamp(ta, keys.length);
                syncPayload();
            });

            ta.addEventListener('compositionend', () => {
                ta.dispatchEvent(new Event('input'));
            });

            for (const k of keys) {
                const td = tdByKey(k);
                if (!td) continue;
                td.addEventListener('mousedown', e => {
                    e.preventDefault();
                    ta.focus({ preventScroll: true });
                    const rect = ta.getBoundingClientRect();
                    const relY = Math.max(0, Math.min(rect.height - 1, e.clientY - rect.top));
                    const li = yToLineIdx(relY, lineH, keys.length);
                    moveCaretToLineEnd(ta, li);
                });
            }

            ta.addEventListener('focus', () => {
                const r = blockRectOfKeys(keys);
                if (!r) return;
                block.dataset.active = '1';
                const rect = clampToTable({
                    left: Math.floor(r.left),
                    top: Math.floor(r.top),
                    width: Math.ceil(r.width),
                    height: Math.ceil(r.height)
                });
                showRingForRect(rect);
            }, true);

            ta.addEventListener('blur', () => {
                block.dataset.active = '0';
                hideRingIfIdle();
            }, true);

            host.appendChild(block);
            host.appendChild(ta);

            blocks.push({
                block,
                ta,
                keys,
                placeRect,
                refreshRing: () => {
                    if (block.dataset.active === '1') {
                        const r = blockRectOfKeys(keys);
                        if (!r) return;
                        const rect = clampToTable({
                            left: Math.floor(r.left),
                            top: Math.floor(r.top),
                            width: Math.ceil(r.width),
                            height: Math.ceil(r.height)
                        });
                        showRingForRect(rect);
                    }
                }
            });
        }

        window.__eb_blocks__ = blocks;
        window.dispatchEvent(new CustomEvent('eb-editor-mounted'));

        addEventListener('resize', () => {
            blocks.forEach(b => { b.placeRect(); b.refreshRing(); });
        });
    }

    /* ===== 프리뷰 마운트 ===== */
    function toIsoDateOrEmpty(text) {
        if (!text) return '';
        const s = String(text).trim();
        let m = s.match(/^(\d{4})[./-](\d{1,2})[./-](\d{1,2})/);
        if (m) return `${m[1]}-${m[2].padStart(2, '0')}-${m[3].padStart(2, '0')}`;
        return '';
    }

    function mount(_, p) {
        const xhost = document.getElementById('xhost');
        if (!p || !Array.isArray(p.cells) || !p.cells.length) {
            xhost.innerHTML = '<div class="alert alert-danger">' + T('DOC_Err_PreviewFailed') + '</div>';
            return;
        }

        const styles = p.styles || {};
        const allRows = p.cells.length;
        let minR = Infinity, maxR = -Infinity, minC = Infinity, maxC = -Infinity;

        const mark = (r, c) => { minR = Math.min(minR, r); maxR = Math.max(maxR, r); minC = Math.min(minC, c); maxC = Math.max(maxC, c); };

        for (let r = 1; r <= allRows; r++) {
            const row = p.cells[r - 1] || [];
            for (let c = 1; c <= row.length; c++) {
                const v = row[c - 1];
                if (v !== '' && v != null) mark(r, c);
                const st = styles[`${r},${c}`];
                if (hasVisibleStyle(st)) mark(r, c);
            }
        }

        (p.merges || []).forEach(m => { const [r1, c1, r2, c2] = m.map(n => parseInt(n, 10) || 0); mark(r1, c1); mark(r2, c2); });

        (Array.isArray(descriptor?.inputs) ? descriptor.inputs : []).forEach(f => { const rc = a1ToRC(f?.a1); if (rc) mark(rc.r, rc.c); });

        if (!isFinite(minR) || !isFinite(minC)) { minR = 1; maxR = 1; minC = 1; maxC = 1; }

        const maxColsFromCells = Math.max(...p.cells.map(r => r.length), 1);
        maxC = Math.min(maxC, maxColsFromCells);
        minC = Math.max(minC, 1);

        const mergeMap = new Map();
        (p.merges || []).forEach(m => {
            let [r1, c1, r2, c2] = m.map(n => parseInt(n, 10));
            r1 = Math.max(r1, minR);
            c1 = Math.max(c1, minC);
            r2 = Math.min(r2, maxR);
            c2 = Math.min(c2, maxC);
            if (r1 > r2 || c1 > c2) return;
            const master = `${r1}-${c1}`;
            mergeMap.set(master, { master: true, rs: r2 - r1 + 1, cs: c2 - c1 + 1 });
            for (let r = r1; r <= r2; r++) for (let c = c1; c <= c2; c++) { const k = `${r}-${c}`; if (k !== master) mergeMap.set(k, { covered: true }); }
        });

        const styleGrid = Array.from({ length: maxR + 1 }, () => Array(maxC + 1).fill(null));
        for (let r = minR; r <= maxR; r++) {
            for (let c = minC; c <= maxC; c++) {
                const key = `${r},${c}`;
                const st = styles[key] || {};
                const border = Object.assign({ l: 'None', r: 'None', t: 'None', b: 'None' }, st.border || {});
                styleGrid[r][c] = { font: st.font || null, align: st.align || null, fill: st.fill || null, border };
            }
        }

        const weight = s => {
            s = String(s || '').toLowerCase();
            if (!s || s === 'none') return 0;
            if (s.includes('double')) return 6;
            if (s.includes('thick')) return 5;
            if (s.includes('mediumdashdotdot') || s.includes('mediumdashdot') || s.includes('mediumdashed') || s.includes('medium')) return 4;
            if (s.includes('dashed') || s.includes('dashdot') || s.includes('dashdotdot')) return 3;
            if (s.includes('dotted') || s.includes('hair')) return 2;
            return 1;
        };
        const stronger = (a, b) => (weight(a) >= weight(b) ? a : b);

        for (let r = minR; r <= maxR; r++) {
            for (let c = minC; c <= maxC; c++) {
                const cur = styleGrid[r][c];
                if (!cur) continue;

                if (c < maxC) {
                    const right = styleGrid[r][c + 1];
                    if (right) {
                        const pick = stronger(cur.border.r, right.border.l);
                        cur.border.r = pick;
                        right.border.l = pick;
                    }
                }

                if (r < maxR) {
                    const down = styleGrid[r + 1][c];
                    if (down) {
                        const pick = stronger(cur.border.b, down.border.t);
                        cur.border.b = pick;
                        down.border.t = pick;
                    }
                }
            }
        }

        const colPxAt = c => {
            const wChar = (p.colW || [])[c - 1];
            return excelColWidthToPx(wChar ?? 8.43);
        };

        const sumColPx = (c1, c2) => {
            let s = 0;
            for (let i = c1; i <= c2; i++) s += colPxAt(i);
            return s;
        };

        const tbl = document.createElement('table');
        tbl.className = 'xlfb';

        const colgroup = document.createElement('colgroup');
        for (let c = minC; c <= maxC; c++) {
            const cg = document.createElement('col');
            cg.style.width = colPxAt(c).toFixed(2) + 'px';
            colgroup.appendChild(cg);
        }
        tbl.appendChild(colgroup);

        const tbody = document.createElement('tbody');
        const rowHeights = Array.isArray(p.rowH) ? p.rowH : [];
        const DEFAULT_ROW_PT = 15;

        for (let r = minR; r <= maxR; r++) {
            const tr = document.createElement('tr');
            const pt = (rowHeights[r - 1] != null) ? rowHeights[r - 1] : DEFAULT_ROW_PT;
            const rowPx = ptToPx(pt);
            tr.style.height = rowPx + 'px';

            for (let c = minC; c <= maxC; c++) {
                const key = `${r}-${c}`;
                const mm = mergeMap.get(key);
                if (mm && mm.covered) continue;

                const td = document.createElement('td');
                td.dataset.rowpx = String(rowPx);

                if (mm && mm.master) {
                    if (mm.rs > 1) td.setAttribute('rowspan', String(mm.rs));
                    if (mm.cs > 1) td.setAttribute('colspan', String(mm.cs));
                }

                if (!(mm && mm.master && mm.cs > 1)) {
                    td.style.width = colPxAt(c) + 'px';
                }

                const cell = document.createElement('div');
                cell.className = 'cellc';
                if (!mm) cell.style.maxHeight = rowPx + 'px';

                //const v = (preview.cells[r - 1]?.[c - 1] ?? '');
                const v = (p.cells[r - 1]?.[c - 1] ?? '');
                cell.appendChild(document.createTextNode(v === '' ? '' : String(v)));

                applyStyleToCell(td, cell, styleGrid[r][c]);

                const m = posToMeta.get(`${r},${c}`);
                const fieldKey = m?.key;
                const fieldType = (m?.type || 'Text').toLowerCase();
                const editable = !!fieldKey && !(mm && !mm.master);

                if (editable) {
                    td.setAttribute('data-key', fieldKey);
                    td.classList.add('eb-editable');

                    if (fieldType === 'date') {
    td.dataset.type = 'date';
    td.classList.add('eb-group');

    const input = document.createElement('input');
    input.type = 'date';
    input.className = 'eb-input-date';

    // 2025.12.31 Changed: 항상 오늘 날짜로 강제(템플릿/셀 값 무시)
    const todayIso = new Date().toISOString().slice(0, 10);
    input.value = todayIso;

    cell.textContent = '';
    cell.appendChild(input);

    const sync = () => { payloadInputs[fieldKey] = input.value || ''; };
    input.addEventListener('change', sync);
    input.addEventListener('blur', sync);

    // 2025.12.31 Changed: 초기에도 무조건 payload에 반영(기존 값 덮어쓰기)
    sync();

    td.addEventListener('mousedown', (e) => {
        if (e.button !== 0) return;
        e.preventDefault();
        input.focus({ preventScroll: true });
        if (typeof input.showPicker === 'function') {
            try { input.showPicker(); } catch { }
        }
    });
}
                }

                td.appendChild(cell);
                tr.appendChild(td);
            }

            tbody.appendChild(tr);
        }

        tbl.appendChild(tbody);

        const totalW = sumColPx(minC, maxC);
        tbl.style.width = totalW + 'px';

        const xhostEl = document.getElementById('xhost');
        xhostEl.innerHTML = '';
        xhostEl.appendChild(tbl);

        window.__DOC_TOTALW__ = Math.max(1, totalW | 0);
        window.__DOC_EFFW__ = Math.max(1, measureEffectiveContentWidth(tbl) | 0);

        applyFinalWidth();
        requestAnimationFrame(() => requestAnimationFrame(updateClampBounds));

        colorizeInputGroups();
        createGroupsWithEditorOverlay();
    }

    /* ===== 초기화/관찰 ===== */
    const host = document.getElementById('doc-scroll');
    escapeFixedTraps(host);
    placeContainer();

    host.addEventListener('scroll', () => {
        if (host.scrollLeft > HMAX) host.scrollLeft = HMAX;
        if (host.scrollLeft < 0) host.scrollLeft = 0;
    }, { passive: true });

    function rerenderAll() {
        placeContainer();
        applyFinalWidth();
        updateClampBounds();
        if (window.__eb_blocks__) {
            window.__eb_blocks__.forEach(b => { b.placeRect?.(); b.refreshRing?.(); });
        }
    }

    async function firstReflow() {
        try { await (document.fonts?.ready || Promise.resolve()); } catch { }
        await new Promise(r => requestAnimationFrame(() => requestAnimationFrame(r)));
        rerenderAll();
        setTimeout(rerenderAll, 0);
    }

    try {
        mount('#xlPreview', preview);
    } catch (e) {
        console.error(e);
        err('DOC_Err_PreviewFailed');
    }

    addEventListener('load', firstReflow, { once: true });
    firstReflow();
    addEventListener('resize', rerenderAll);

    const xhostObsTarget = document.getElementById('xhost');
    let moQueued = false;
    new MutationObserver(() => {
        if (moQueued) return;
        moQueued = true;
        requestAnimationFrame(() => {
            const tbl = document.querySelector('#xhost table');
            if (tbl) {
                window.__DOC_EFFW__ = Math.max(Number(window.__DOC_EFFW__) || 0, measureEffectiveContentWidth(tbl) | 0);
            }
            rerenderAll();
            moQueued = false;
        });
    }).observe(xhostObsTarget, { attributes: true, childList: true, subtree: true });

    /* ===== 메일 수신자 자동 구성 ===== */
    function __collectFirstApproverEmailsFromDescriptor() {
        const ds = Array.isArray(window.descriptor?.approvals) ? window.descriptor.approvals : [];
        if (!ds.length) return [];

        let minOrder = Infinity;
        for (const a of ds) {
            const ord = (a?.order == null ? 1 : Number(a.order) || 0);
            if (ord < minOrder) minOrder = ord;
        }

        const first = ds.filter(a => {
            const ord = (a?.order == null ? 1 : Number(a.order) || 0);
            return ord === minOrder;
        });

        const emails = [];
        for (const a of first) {
            if (Array.isArray(a.users)) {
                for (const u of a.users) {
                    const e = u?.email || u?.mail || u?.Email;
                    if (e) emails.push(String(e));
                }
            }
            if (a.user) {
                const e = a.user?.email || a.user?.mail || a.user?.Email;
                if (e) emails.push(String(e));
            }
            if (Array.isArray(a.emails)) {
                for (const e of a.emails) if (e) emails.push(String(e));
            }
            if (a.email) emails.push(String(a.email));
        }

        return [...new Set(emails.filter(Boolean))];
    }

    function buildApprovalsForPost() {
        if (window.__approvals && (Array.isArray(window.__approvals.to) || Array.isArray(window.__approvals.steps))) {
            return window.__approvals;
        }
        const toEmails = __collectFirstApproverEmailsFromDescriptor();
        return { to: toEmails };
    }

    function uniqEmails(list) {
        const seen = new Set();
        const result = [];
        for (const raw of (list || [])) {
            if (!raw) continue;
            const s = String(raw).trim();
            if (!s) continue;
            const key = s.toLowerCase();
            if (seen.has(key)) continue;
            seen.add(key);
            result.push(s);
        }
        return result;
    }

    function buildMailForPost() {
        const firstApprovers = uniqEmails(__collectFirstApproverEmailsFromDescriptor());

        if (window.__mail && typeof window.__mail === 'object') {
            const m = window.__mail;
            const baseTo = Array.isArray(m.to) ? m.to : (m.to ? [m.to] : []);
            const baseCc = Array.isArray(m.cc) ? m.cc : (m.cc ? [m.cc] : []);
            const baseBcc = Array.isArray(m.bcc) ? m.bcc : (m.bcc ? [m.bcc] : []);
            const merged = uniqEmails([...baseTo, ...baseCc, ...baseBcc]);
            const to = firstApprovers.length ? firstApprovers : merged;

            return {
                to: to,
                cc: [],
                bcc: [],
                subject: m.subject || '',
                body: m.body || '',
                send: (m.send !== false),
                from: m.from || null
            };
        }

        const dm = window.descriptor?.mail || {};
        const baseTo = Array.isArray(dm.to) ? dm.to : (dm.to ? [dm.to] : []);
        const baseCc = Array.isArray(dm.cc) ? dm.cc : (dm.cc ? [dm.cc] : []);
        const baseBcc = Array.isArray(dm.bcc) ? dm.bcc : (dm.bcc ? [dm.bcc] : []);

        const mergedAll = uniqEmails([...baseTo, ...baseCc, ...baseBcc]);
        const finalTo = firstApprovers.length ? firstApprovers : mergedAll;

        return {
            to: finalTo,
            cc: [],
            bcc: [],
            subject: dm.subject || '',
            body: dm.body || '',
            send: (dm.send !== false),
            from: dm.from || null
        };
    }

    function collectSelectedRecipientUserIds() {
        function uniq(list) {
            const seen = new Set();
            const out = [];
            for (const raw of (list || [])) {
                const s = String(raw || '').trim();
                if (!s) continue;
                const k = s.toLowerCase();
                if (seen.has(k)) continue;
                seen.add(k);
                out.push(s);
            }
            return out;
        }

        function parseRaw(raw) {
            raw = String(raw || '').trim();
            if (!raw) return [];

            if (raw.startsWith('[')) {
                try {
                    const arr = JSON.parse(raw);
                    if (Array.isArray(arr)) return uniq(arr.map(x => String(x || '').trim()).filter(Boolean));
                } catch { }
            }

            return uniq(raw.split(/[,\s;]+/g).map(s => (s || '').trim()).filter(Boolean));
        }

        const root = document.getElementById('doc-recipient-select');

        if (root) {
            const one =
                root.querySelector('input[name="SelectedRecipientUserIds"]')?.value ||
                root.querySelector('textarea[name="SelectedRecipientUserIds"]')?.value ||
                '';
            const parsedOne = parseRaw(one);
            if (parsedOne.length) return parsedOne;

            const many = root.querySelectorAll('input[name="SelectedRecipientUserIds"]');
            if (many && many.length > 1) {
                const list = [];
                many.forEach(el => {
                    const v = (el && typeof el.value === 'string') ? el.value.trim() : '';
                    if (v) list.push(v);
                });
                const parsedMany = uniq(list);
                if (parsedMany.length) return parsedMany;
            }

            const ds = root.getAttribute('data-selected') || (root.dataset ? root.dataset.selected : '') || '';
            const parsedDs = parseRaw(ds);
            if (parsedDs.length) return parsedDs;
        }

        const globalOne = document.querySelector('input[name="SelectedRecipientUserIds"],textarea[name="SelectedRecipientUserIds"]');
        if (globalOne && typeof globalOne.value === 'string') {
            const parsed = parseRaw(globalOne.value);
            if (parsed.length) return parsed;
        }

        const globalMany = document.querySelectorAll('input[name="SelectedRecipientUserIds"]');
        if (globalMany && globalMany.length > 1) {
            const list = [];
            globalMany.forEach(el => {
                const v = (el && typeof el.value === 'string') ? el.value.trim() : '';
                if (v) list.push(v);
            });
            const parsedMany = uniq(list);
            if (parsedMany.length) return parsedMany;
        }

        return [];
    }

    function buildRequestBody(tpl) {
        // 2025.12.29 Changed: 서버 ComposePostDto 프로퍼티명 불일치(대소문자/네이밍)로 인한 값 유실 방지 위해 키를 이중 전송
        const selectedIds = collectSelectedRecipientUserIds();

        return {
            templateCode: tpl,
            inputs: { ...(window.payloadInputs || {}) },
            approvals: buildApprovalsForPost(),
            mail: buildMailForPost(),
            SelectedRecipientUserIds: selectedIds,
            selectedRecipientUserIds: selectedIds
            // A안: attachments 메타 배열 전송 제거 (files는 FormData로 전송)
        };
    }

    /* ===== 템플릿 코드 회수 ===== */
    function getTemplateCode() {
        const d1 = document.getElementById('doc-scroll')?.dataset?.templateCode?.trim();
        if (d1) return d1;

        const form = document.getElementById('doc-form');
        const v1 = form?.querySelector('input[name=TemplateCode]')?.value?.trim();
        if (v1) return v1;

        const v1b = form?.querySelector('input[name=templateCode]')?.value?.trim();
        if (v1b) return v1b;

        try {
            const qs = new URLSearchParams(location.search);
            const v2 = (qs.get('templateCode') || qs.get('TemplateCode') || '').trim();
            if (v2) return v2;
        } catch { }

        const v3 = (window.descriptor && (window.descriptor.templateCode || window.descriptor.code) || '');
        if (v3) return String(v3).trim();

        try {
            const prev = JSON.parse(document.getElementById('PreviewJson')?.textContent || '{}');
            const v3b = (prev?.meta?.templateCode || '');
            if (v3b) return String(v3b).trim();
        } catch { }

        const v4 = (window.__tplFromServer || '').trim?.();
        if (v4) return v4;

        return (window.__tplFromServer || '').trim();
    }

    function replacePreviewJsonToDom(jsonObj) {
        try {
            const holder = document.getElementById('PreviewJson');
            holder.textContent = JSON.stringify(jsonObj);
            mount('#xlPreview', jsonObj);
        } catch { }
    }

    function showDebugPopup(data) {
        const mask = document.createElement('div');
        mask.className = 'eb-modal-mask';

        const modal = document.createElement('div');
        modal.className = 'eb-modal';

        const title = (window.__RESX && window.__RESX['DOC_Debug_Title']) || 'DOC_Debug_Title';
        const hint = (window.__RESX && window.__RESX['DOC_Debug_Hint']) || 'DOC_Debug_Hint';
        const btnCancelText = T('DOC_Btn_Cancel');
        const btnOkText = (window.__RESX && window.__RESX['DOC_Btn_ContinueSave']) || 'DOC_Btn_ContinueSave';

        const header = document.createElement('header');
        header.innerHTML =
            '<strong>' + decodeHtmlEntities(title) + '</strong>' +
            '<span style="font-size:.85rem;color:#6b7280">' +
            decodeHtmlEntities(hint) +
            '</span>';

        const pre = document.createElement('pre');
        pre.textContent = JSON.stringify(data, null, 2);

        const body = document.createElement('div');
        body.className = 'body';
        body.appendChild(pre);

        const footer = document.createElement('footer');
        const btnCancel = Object.assign(document.createElement('button'), { className: 'btn btn-outline', textContent: decodeHtmlEntities(btnCancelText) });
        const btnOk = Object.assign(document.createElement('button'), { className: 'btn btn-primary', textContent: decodeHtmlEntities(btnOkText) });

        footer.append(btnCancel, btnOk);
        modal.append(header, body, footer);
        mask.appendChild(modal);
        document.body.appendChild(mask);

        return new Promise(resolve => {
            btnCancel.onclick = () => { document.body.removeChild(mask); resolve(false); };
            btnOk.onclick = () => { document.body.removeChild(mask); resolve(true); };
            mask.addEventListener('click', (e) => {
                if (e.target === mask) { document.body.removeChild(mask); resolve(false); }
            });
        });
    }

    /* ===== 저장 로직 (A안: FormData + files + dtoJson) ===== */
    const submitBtn = document.querySelector('[data-doc-submit]') || document.getElementById('btn-save');
    const cancelBtn = document.getElementById('btn-cancel');

    // 2025.12.29 Changed: 저장 핸들러는 아래 submitBtn 클릭 핸들러 1벌만 유지 (중복 실행 위험 제거)
    submitBtn?.addEventListener('click', async () => {
        // (중략: 기존 payloadInputs 보강/템플릿코드 체크 로직은 그대로)

        // 파일은 input 기준(선택만, 업로드 없음)
        const picked = dedupeFilesKeepFirst(Array.from(fileInput?.files || []));

        const form = document.getElementById('doc-form');
        const tpl = (getTemplateCode() || '').trim();
        if (!tpl) {
            err('DOC_Val_TemplateRequired');
            return;
        }

        const bodyObj = buildRequestBody(tpl); // attachments 넣지 않는 상태 유지
        const csrf = await getCsrf();

        submitBtn.disabled = true;
        try {
            // 1) 문서 저장: 반드시 JSON
            const r = await fetch('/Doc/Create', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    [csrf.headerName]: csrf.token
                },
                credentials: 'same-origin',
                body: JSON.stringify(bodyObj)
            });

            const res = await r.json().catch(() => null);
            if (!r.ok || !res) {
                const msgs = Array.isArray(res?.messages) ? res.messages : null;
                err(msgs && msgs.length ? msgs : 'DOC_Err_SaveFailed');
                return;
            }

            // 서버가 docId 를 내려준다는 전제 (없으면 즉시 실패 처리)
            const docId = (res.docId || res.DocId || '').toString().trim();
            if (!docId) {
                err('DOC_Err_SaveFailed');
                return;
            }

            // 2) 첨부 업로드: docId 기반 최종 저장 + DocumentFiles INSERT
            if (picked.length) {
                const fd = new FormData();
                for (const f of picked) fd.append('files', f, f.name);

                // --- PATCH 3: 폼필드 토큰도 함께 전달(서버 설정 다양성 대응) ---
                if (csrf && csrf.token) {
                    fd.append('__RequestVerificationToken', csrf.token);
                }

                const up = await fetch('/Doc/Upload?docId=' + encodeURIComponent(docId), {
                    method: 'POST',
                    headers: { [csrf.headerName]: csrf.token },
                    credentials: 'same-origin',
                    body: fd
                });

                const upRes = await up.json().catch(() => null);
                if (!up.ok || !upRes) {
                    err('DOC_Err_UploadFailed');
                    return;
                }
            }

            ok('DOC_Msg_Saved');

/* 2025.12.31 Added: 저장 성공 시 Detail로 이동 (docId 기준) */
try {
    const u = new URL(location.origin + '/Doc/Detail');
    u.searchParams.set('id', docId);
    location.href = u.toString();
    return; // 이후 로직 실행 방지
} catch {
    // URL 생성 실패 시 최소 폴백
    location.href = '/Doc/Detail?id=' + encodeURIComponent(docId);
    return;
}
        } catch (e) {
            console.error(e);
            err('DOC_Err_SaveFailed');
        } finally {
            submitBtn.disabled = false;
        }
    });

    function ensureTemplateCode() {
        const form = document.getElementById('doc-form');
        const hid = form?.querySelector('input[name=TemplateCode]');
        const fromHidden = (hid?.value || '').trim();
        const fromDesc = (window.descriptor?.templateCode || '').trim();
        const fromServer = '@(templateCode ?? string.Empty)'.trim();
        const resolved = fromHidden || fromDesc || fromServer;
        if (hid && hid.value !== resolved) hid.value = resolved;

        const host = document.getElementById('doc-scroll');
        if (host && resolved) host.dataset.templateCode = resolved;

        return resolved;
    }

    addEventListener('DOMContentLoaded', () => { ensureTemplateCode(); });

    cancelBtn?.addEventListener('click', () => {
        history.length > 1 ? history.back() : location.href = '/Doc/New';
    });

    // 페이지 로드 시 현재 첨부 표시
    renderAttachListFromInput();
})();
</script>
}
