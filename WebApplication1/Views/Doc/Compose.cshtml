@* 2025.10.29 Changed: 보조 가로 스크롤바를 컨테이너(#doc-scroll) 내부 sticky 하단으로 이동, 표시 시에만 높이 예약; 동적 폭 변경 시 동기 재계산(ResizeObserver); 고정 레이어 제거로 헤더/푸터 가림 및 좌우 시작점 불일치 해소 *@
@model WebApplication1.Models.DocTLViewModel
@inject Microsoft.Extensions.Localization.IStringLocalizer<SharedResource> S
@{
    ViewData["Title"] = S["DOC_Title_Compose"];
    var templateCode = (string?)ViewBag.TemplateCode
                        ?? (Context?.Request?.Query["templateCode"].ToString() ?? string.Empty);
    var templateTitle = (string?)ViewBag.TemplateTitle ?? string.Empty;
    var descJson = (string?)ViewBag.DescriptorJson ?? "{}";
    var previewJson = (string?)ViewBag.PreviewJson ?? "{}";
}
<style>
    html, body {
        height: 100%;
        overflow: hidden !important; /* 전역 스크롤 차단 */
        background: #fff;
        margin: 0;
    }

    /* 단일 스크롤 컨테이너 */
    #doc-scroll {
        position: fixed;
        inset: 0 0 0 0; /* 상단/좌우/하단은 JS에서 헤더/사이드바 인셋 반영 */
        overflow: auto !important;
        box-sizing: border-box;
        background: #fff;
        z-index: 2;
        scrollbar-gutter: stable both-edges;
        padding: 0; /* xbar는 표시 시 JS로 padding-bottom을 부여 */
    }

    /* 상위 레이아웃 간섭 제거용 */
    .doc-unclip {
        overflow: visible !important;
        max-width: none !important;
        transform: none !important;
        will-change: auto !important;
        filter: none !important;
        contain: none !important;
    }

    .page-header {
        display: flex;
        align-items: center;
        gap: 12px;
        padding: 16px;
        margin: 0;
    }
    .page-header h3 { margin: 0; }

    .dbg { margin: 16px; max-width: 100%; overflow: hidden; }
    .dbg > .box { background: #f7f7f9; border: 1px solid #e1e1e8; border-radius: 6px; padding: 12px; }
    .dbg .ttl { font-weight: 700; margin-bottom: 6px; }
    .dbg pre { margin: 0; white-space: pre-wrap; word-break: break-all; }

    /* 프리뷰 호스트: 여백 제거(우측 공백 방지) */
    #xlPreview { position: relative; display: block; margin: 0; padding: 0; overflow: visible; }
    #xhost { display: inline-block; width: auto; max-width: none; }

    .xlfb { border-collapse: collapse; table-layout: fixed; position: relative; }
    .xlfb td, .xlfb th { box-sizing: border-box; position: relative; }
    .xlfb thead, .xlfb tbody th { display: none; }
    .xlfb td { padding: 0; vertical-align: middle; overflow: hidden; word-break: break-word; white-space: pre-wrap; }

    .cellc { padding: .0rem .45rem; font-size: .925rem; line-height: 1.2; max-height: 100%; overflow: hidden; display: block; }
    .ta-left { text-align: left } .ta-center { text-align: center } .ta-right { text-align: right }
    .va-top { vertical-align: top } .va-middle { vertical-align: middle } .va-bottom { vertical-align: bottom }
    .wrap { white-space: pre-line }

    .eb-input-date {
        width: 100%; border: none; outline: none; background: transparent; font: inherit; padding: 0; margin: 0; height: 1.6em;
    }

    .eb-block {
        position: absolute; box-sizing: border-box; background: transparent; color: inherit; outline: none;
        white-space: pre; overflow: hidden; scrollbar-width: none;
    }
    .eb-block:hover { outline: 1px dashed #d4c36a }
    .eb-block:focus { outline: 2px solid #d7b500 }

    .form-actions { margin: 16px; padding: 12px 0; border-top: 1px solid #e9ecef; display: flex; gap: 8px }
    .action-btn { width: 140px; height: 36px; white-space: nowrap }

    /* 보조 가로 스크롤바: 컨테이너 내부 sticky 하단 */
    #xbar {
        position: sticky;
        bottom: 0;
        left: 0;
        right: 0;
        height: 16px;
        background: #fff;
        overflow-x: auto;
        overflow-y: hidden;
        z-index: 3;              /* 컨테이너 내부에서 세로 스크롤보다 위 */
        display: none;           /* 필요 시에만 표시 */
        border-top: none;        /* 필요 시 JS로 on/off */
    }
    #xbar .rail { height: 1px; }

    /* 50px 단위 눈금자 */
    #xhost .xl-ruler {
        position: relative; height: 22px; margin: 0; pointer-events: none;
        border-bottom: 1px solid rgba(0,0,0,.35);
        background-image:
            repeating-linear-gradient(to right, rgba(0,0,0,.35) 0px, rgba(0,0,0,.35) 1px, transparent 1px, transparent 50px),
            repeating-linear-gradient(to right, rgba(0,0,0,.55) 0px, rgba(0,0,0,.55) 2px, transparent 2px, transparent 100px);
        background-repeat: repeat-x; background-position: left bottom,left bottom;
        background-size: 50px 22px,100px 22px;
    }
    #xhost .xl-ruler::after {
        content: ""; position: absolute; left: 0; right: 0; top: 0; height: 1px;
        background: repeating-linear-gradient(to right, rgba(0,0,0,.12) 0px, rgba(0,0,0,.12) 25px, transparent 25px, transparent 50px);
    }

    @@media print {
        #doc-scroll { overflow: visible; position: static; inset: auto; height: auto }
        #xbar, .form-actions { display: none !important }
        .xlfb { outline: 1px solid #000; outline-offset: -1px }
    }
</style>

<div id="doc-scroll">
    <div class="page-header">
        <h3>@S["DOC_Title_Compose"]</h3>
        <span class="text-muted">@templateTitle</span>
    </div>

    <div id="doc-alert" class="mb-2" aria-live="polite"></div>
    <div id="dbg" class="dbg"></div>

    <form id="doc-form" method="post" asp-controller="Doc" asp-action="Create" novalidate>
        <input type="hidden" name="TemplateCode" value="@templateCode" />
        <script type="application/json" id="DescriptorJson">@Html.Raw(descJson)</script>
        <script type="application/json" id="PreviewJson">@Html.Raw(previewJson)</script>

        <div id="xlPreview"><div id="xhost"></div></div>

        <div class="form-actions">
            <button type="button" id="btn-save" class="btn btn-primary action-btn">@S["DOC_Btn_SaveDocument"]</button>
            <button type="button" id="btn-cancel" class="btn btn-outline-secondary action-btn">@S["DOC_Btn_Cancel"]</button>
        </div>
    </form>

    <!-- ★ 컨테이너 내부 sticky 하단으로 이동 -->
    <div id="xbar"><div class="rail"></div></div>
</div>

@section Scripts {
<script src="~/js/eb.csrf.js"></script>
<script>
(function () {
    /* ===== 유틸 ===== */
    const lockRootScroll = () => {
        document.documentElement.style.setProperty('overflow-x', 'hidden', 'important');
        document.body.style.setProperty('overflow-x', 'hidden', 'important');
        document.documentElement.style.setProperty('overflow-y', 'hidden', 'important');
        document.body.style.setProperty('overflow-y', 'hidden', 'important');
    };
    function escapeFixedTraps(el, maxHops = 12, maxApply = 6) {
        let n = el.parentElement, hops = 0, applied = 0;
        while (n && hops < maxHops && applied < maxApply) {
            const cs = getComputedStyle(n);
            const hasTrap = (cs.transform && cs.transform !== 'none')
                || (cs.willChange && cs.willChange.includes('transform'))
                || (cs.filter && cs.filter !== 'none') || (cs.contain && cs.contain !== 'none');
            const clips = /(auto|scroll|hidden|clip)/.test(cs.overflowX) || /(auto|scroll|hidden|clip)/.test(cs.overflowY);
            if (hasTrap || clips) { n.classList.add('doc-unclip'); applied++; }
            n = n.parentElement; hops++;
        }
    }
    const $alert = () => document.getElementById('doc-alert');
    const info = m => { $alert()?.replaceChildren(Object.assign(document.createElement('div'), { className: 'alert alert-info', textContent: m })) }
    const err  = m => { $alert()?.replaceChildren(Object.assign(document.createElement('div'), { className: 'alert alert-danger', textContent: m || 'DOC_Err_PreviewFailed' })) }
    const dbgBox = document.getElementById('dbg');
    const BASE_TITLE = document.title;

    function dbg(title, data) {
        const wrap = document.createElement('div'); wrap.className = 'box';
        const h = document.createElement('div'); h.className = 'ttl'; h.textContent = '[HS-DBG] ' + title;
        const pre = document.createElement('pre'); pre.textContent = (typeof data === 'string') ? data : JSON.stringify(data, null, 2);
        wrap.appendChild(h); wrap.appendChild(pre); dbgBox.appendChild(wrap);
    }

    /* ===== 스크롤 디버깅 ===== */
    let _sync = { docMax: 0, barMax: 0, toDoc: (x)=>0, toBar:(x)=>0 };
    let _rafScrollDebug = 0;
    function updateScrollDebug() {
        if (_rafScrollDebug) return;
        _rafScrollDebug = requestAnimationFrame(() => {
            _rafScrollDebug = 0;
            const sc = document.getElementById('doc-scroll');
            const xbar = document.getElementById('xbar');
            if (!sc || !xbar) return;
            const docCur = sc.scrollLeft | 0, docMax = _sync.docMax | 0;
            const barCur = xbar.scrollLeft | 0, barMax = _sync.barMax | 0;
            const msg = `SCROLL docX=${docCur}/${docMax} barX=${barCur}/${barMax}`;
            const host = $alert();
            if (host) {
                const box = document.createElement('div');
                box.className = 'alert alert-secondary';
                box.textContent = msg;
                host.replaceChildren(box);
            }
            document.title = `${BASE_TITLE} | X ${docCur}/${docMax} · B ${barCur}/${barMax}`;
        });
    }

    /* 헤더/사이드바 인셋 추정 */
    function computeEdgeInsets() {
        const all = Array.from(document.body.getElementsByTagName('*'));
        const vw = Math.max(320, window.innerWidth), vh = Math.max(320, window.innerHeight);
        let topInset = 0, leftInset = 0;
        for (const el of all) {
            const cs = getComputedStyle(el), pos = cs.position;
            if (pos !== 'fixed' && pos !== 'sticky') continue;
            const r = el.getBoundingClientRect(), w = r.right - r.left, h = r.bottom - r.top;
            const touchesLeft = (r.left <= 1) && (r.right > 1) && (w > 24) && (w <= vw * 0.6) && (r.top < vh) && (r.bottom > 0);
            if (touchesLeft) leftInset = Math.max(leftInset, Math.round(r.right));
            const touchesTop = (r.top <= 1) && (r.bottom > 1) && (h > 16) && (h <= vh * 0.5) && (r.left < vw) && (r.right > 0);
            if (touchesTop) topInset = Math.max(topInset, Math.round(r.bottom));
        }
        topInset = Math.min(topInset, Math.floor(vh * 0.5));
        leftInset = Math.min(leftInset, Math.floor(vw * 0.5));
        return { topInset, leftInset };
    }

    function placeScrollHost() {
        lockRootScroll();
        const host = document.getElementById('doc-scroll');
        const { topInset, leftInset } = computeEdgeInsets();
        host.style.top = topInset + 'px';
        host.style.left = leftInset + 'px';
        host.style.right = '0px';
        host.style.bottom = '0px';
        host.style.setProperty('overflow-x', 'auto', 'important');
        host.style.setProperty('overflow-y', 'auto', 'important');
        clampBoth();
        updateScrollDebug();
    }

    function readJson(id) {
        try {
            const el = document.getElementById(id); if (!el) return {};
            const raw = el.textContent || ''; const v = JSON.parse(raw);
            return (typeof v === 'string') ? JSON.parse(v) : v;
        } catch (e) { dbg('Parse error for ' + id, String(e)); return {}; }
    }

    const descriptor = readJson('DescriptorJson'), preview = readJson('PreviewJson');

    function a1ToRC(a1) {
        if (!a1) return null; const m = String(a1).toUpperCase().match(/^([A-Z]+)(\d+)$/);
        if (!m) return null; const letters = m[1], row = parseInt(m[2], 10); let col = 0;
        for (let i = 0; i < letters.length; i++) col = col * 26 + (letters.charCodeAt(i) - 64);
        return { r: row, c: col };
    }

    const posToMeta = new Map();
    (Array.isArray(descriptor?.inputs) ? descriptor.inputs : []).forEach(f => {
        if (!f?.key) return; const rc = a1ToRC(f.a1 || ''); if (!rc) return;
        posToMeta.set(`${rc.r},${rc.c}`, { key: String(f.key), type: String(f.type || 'Text'), rc });
    });

    const payloadInputs = {};
    const excelColWidthToPx = W => { const w = Number(W); if (!isFinite(w) || w < 0) return 0; return Math.max(0, Math.floor(w * 7 + 5)); };
    const ptToPx = pt => ((Number(pt) || 0) * 96 / 72);
    function hasVisibleStyle(st) {
        if (!st) return false;
        if (st.fill && st.fill.bg) return true;
        if (st.font && (st.font.bold || st.font.italic || st.font.underline || st.font.size || st.font.name)) return true;
        const b = st.border || {}; return !!((b.l && b.l !== 'None') || (b.r && b.r !== 'None') || (b.t && b.t !== 'None') || (b.b && b.b !== 'None'));
    }

    /* 실제 그려진 영역 오른쪽 끝 픽셀 */
    function measureEffectiveContentWidth(tblEl) {
        if (!tblEl) return 0;
        const baseLeft = tblEl.getBoundingClientRect().left;
        let maxRight = 0;
        const tds = tblEl.querySelectorAll('td');
        for (let i = 0; i < tds.length; i++) {
            const td = tds[i];
            const cs = getComputedStyle(td);
            const hasBorder =
                (parseFloat(cs.borderLeftWidth) || 0) > 0 ||
                (parseFloat(cs.borderRightWidth) || 0) > 0 ||
                (parseFloat(cs.borderTopWidth) || 0) > 0 ||
                (parseFloat(cs.borderBottomWidth) || 0) > 0;
            const hasText = (td.textContent || '').trim().length > 0;
            const isEditable = td.classList.contains('eb-editable');
            if (hasBorder || hasText || isEditable) {
                const r = td.getBoundingClientRect().right;
                if (r > maxRight) maxRight = r;
            }
        }
        const effective = Math.ceil(maxRight - baseLeft);
        return isFinite(effective) && effective > 0 ? effective : 0;
    }

    /* ===== 표 렌더 ===== */
    function mount(sel, p) {
        const previewHost = document.querySelector(sel); if (!previewHost) return;
        const xhost = document.getElementById('xhost');
        if (!p || !Array.isArray(p.cells) || !p.cells.length) {
            xhost.innerHTML = '<div class="alert alert-danger">DOC_Err_PreviewFailed</div>'; return;
        }

        const styles = p.styles || {}; const allRows = p.cells.length;
        let minR = Infinity, maxR = -Infinity, minC = Infinity, maxC = -Infinity;
        const mark = (r, c) => { minR = Math.min(minR, r); maxR = Math.max(maxR, r); minC = Math.min(minC, c); maxC = Math.max(maxC, c); };
        for (let r = 1; r <= allRows; r++) {
            const row = p.cells[r - 1] || [];
            for (let c = 1; c <= row.length; c++) {
                const v = row[c - 1]; if (v !== '' && v != null) mark(r, c);
                const st = styles[`${r},${c}`]; if (hasVisibleStyle(st)) mark(r, c);
            }
        }
        (p.merges || []).forEach(m => { const [r1, c1, r2, c2] = m.map(n => parseInt(n, 10) || 0); mark(r1, c1); mark(r2, c2); });
        (Array.isArray(descriptor?.inputs) ? descriptor.inputs : []).forEach(f => { const rc = a1ToRC(f?.a1); if (rc) mark(rc.r, rc.c); });
        if (!isFinite(minR) || !isFinite(minC)) { minR = 1; maxR = 1; minC = 1; maxC = 1; }
        const maxColsFromCells = Math.max(...p.cells.map(r => r.length), 1);
        maxC = Math.min(maxC, maxColsFromCells); minC = Math.max(minC, 1);

        const mergeMap = new Map();
        (p.merges || []).forEach(m => {
            let [r1, c1, r2, c2] = m.map(n => parseInt(n, 10));
            r1 = Math.max(r1, minR); c1 = Math.max(c1, minC); r2 = Math.min(r2, maxR); c2 = Math.min(c2, maxC);
            if (r1 > r2 || c1 > c2) return;
            const master = `${r1}-${c1}`; mergeMap.set(master, { master: true, rs: r2 - r1 + 1, cs: c2 - c1 + 1 });
            for (let r = r1; r <= r2; r++) for (let c = c1; c <= c2; c++) { const k = `${r}-${c}`; if (k !== master) mergeMap.set(k, { covered: true }); }
        });

        const styleGrid = Array.from({ length: maxR + 1 }, () => Array(maxC + 1).fill(null));
        for (let r = minR; r <= maxR; r++) for (let c = minC; c <= maxC; c++) {
            const key = `${r},${c}`, st = styles[key] || {};
            const border = Object.assign({ l: 'None', r: 'None', t: 'None', b: 'None' }, st.border || {});
            styleGrid[r][c] = { font: st.font || null, align: st.align || null, fill: st.fill || null, border };
        }
        const weight = s => { s = String(s || '').toLowerCase(); if (!s || s === 'none') return 0;
            if (s.includes('double')) return 6; if (s.includes('thick')) return 5;
            if (s.includes('mediumdashdotdot') || s.includes('mediumdashdot') || s.includes('mediumdashed') || s.includes('medium')) return 4;
            if (s.includes('dashed') || s.includes('dashdot') || s.includes('dashdotdot')) return 3;
            if (s.includes('dotted') || s.includes('hair')) return 2; return 1; };
        const stronger = (a, b) => (weight(a) >= weight(b) ? a : b);
        for (let r = minR; r <= maxR; r++) {
            for (let c = minC; c <= maxC; c++) {
                const cur = styleGrid[r][c]; if (!cur) continue;
                if (c < maxC) { const right = styleGrid[r][c + 1]; if (right) { const pick = stronger(cur.border.r, right.border.l); cur.border.r = pick; right.border.l = pick; } }
                if (r < maxR) { const down = styleGrid[r + 1][c]; if (down) { const pick = stronger(cur.border.b, down.border.t); cur.border.b = pick; down.border.t = pick; } }
            }
        }

        const colPxAt = c => { const wChar = (p.colW || [])[c - 1]; return excelColWidthToPx(wChar ?? 8.43); }
        const sumColPx = (c1, c2) => { let s = 0; for (let i = c1; i <= c2; i++) s += colPxAt(i); return s; }

        const tbl = document.createElement('table'); tbl.className = 'xlfb';
        const colgroup = document.createElement('colgroup');
        for (let c = minC; c <= maxC; c++) { const cg = document.createElement('col'); cg.style.width = colPxAt(c).toFixed(2) + 'px'; colgroup.appendChild(cg); }
        tbl.appendChild(colgroup);

        const tbody = document.createElement('tbody');
        const rowHeights = Array.isArray(p.rowH) ? p.rowH : []; const DEFAULT_ROW_PT = 15;
        for (let r = minR; r <= maxR; r++) {
            const tr = document.createElement('tr');
            const pt = (rowHeights[r - 1] != null) ? rowHeights[r - 1] : DEFAULT_ROW_PT;
            const rowPx = ptToPx(pt); tr.style.height = rowPx + 'px';
            for (let c = minC; c <= maxC; c++) {
                const key = `${r}-${c}`, mm = mergeMap.get(key); if (mm && mm.covered) continue;
                const td = document.createElement('td'); td.dataset.rowpx = String(rowPx);
                if (mm && mm.master) { if (mm.rs > 1) td.setAttribute('rowspan', String(mm.rs)); if (mm.cs > 1) td.setAttribute('colspan', String(mm.cs)); }
                let spanCols = 1; if (mm && mm.master && mm.cs > 1) spanCols = mm.cs;
                if (spanCols === 1) td.style.width = colPxAt(c) + 'px'; else td.style.removeProperty('width');

                const cell = document.createElement('div'); cell.className = 'cellc';
                if (!mm) cell.style.maxHeight = rowPx + 'px';
                const v = (p.cells[r - 1]?.[c - 1] ?? ''); cell.appendChild(document.createTextNode(v === '' ? '' : String(v)));
                applyStyleToCell(td, cell, styleGrid[r][c]);

                const meta = posToMeta.get(`${r},${c}`); const fieldKey = meta?.key;
                const fieldType = (meta?.type || 'Text').toLowerCase(); const editable = !!fieldKey && !(mm && !mm.master);
                if (editable) {
                    td.setAttribute('data-key', fieldKey); td.classList.add('eb-editable');
                    if (fieldType === 'date') {
                        const input = document.createElement('input'); input.type = 'date'; input.className = 'eb-input-date';
                        input.value = toIsoDateOrEmpty(cell.textContent || ''); cell.textContent = ''; cell.appendChild(input);
                        input.addEventListener('change', () => payloadInputs[fieldKey] = input.value || '');
                        input.addEventListener('blur', () => payloadInputs[fieldKey] = input.value || '');
                        if (!(fieldKey in payloadInputs)) payloadInputs[fieldKey] = input.value || '';
                    }
                }
                td.appendChild(cell); tr.appendChild(td);
            }
            tbody.appendChild(tr);
        }
        tbl.appendChild(tbody);

        const totalW = sumColPx(minC, maxC);
        tbl.style.width = totalW + 'px';

        xhost.innerHTML = '';
        const ruler = document.createElement('div'); ruler.className = 'xl-ruler';
        xhost.style.width = totalW + 'px';
        ruler.style.width = totalW + 'px';
        xhost.appendChild(ruler); xhost.appendChild(tbl);

        // 초기 동기화 계산
        updateScrollSyncFromDom();
        // 오토플로우 블록
        createSingleBlocks();

        // 크기 변화 감지 → 동기화 갱신
        const sc = document.getElementById('doc-scroll');
        const xbar = document.getElementById('xbar');
        const ro = new ResizeObserver(() => { updateScrollSyncFromDom(); clampBoth(); });
        ro.observe(sc);
        ro.observe(tbl);
        ro.observe(xbar);
    }

    /* 스타일 적용 */
    function applyStyleToCell(td, cell, st) {
        if (!st || typeof st !== 'object') return;
        if (st.font) {
            if (st.font.name) cell.style.fontFamily = st.font.name;
            if (st.font.size) cell.style.fontSize = ptToPx(st.font.size) + 'px';
            if (st.font.bold) cell.style.fontWeight = '700';
            if (st.font.italic) cell.style.fontStyle = 'italic';
            if (st.font.underline) cell.style.textDecoration = 'underline';
        }
        if (st.align) {
            const h = String(st.align.h || '').toLowerCase();
            cell.classList.remove('ta-left','ta-center','ta-right');
            if (h === 'center') cell.classList.add('ta-center'); else if (h === 'right') cell.classList.add('ta-right'); else cell.classList.add('ta-left');
            const vAlign = String(st.align.v || '').toLowerCase();
            td.classList.remove('va-top','va-middle','va-bottom');
            if (vAlign === 'top') td.classList.add('va-top'); else if (vAlign === 'center' || vAlign === 'middle') td.classList.add('va-middle'); else td.classList.add('va-bottom');
            if (st.align.wrap) cell.classList.add('wrap');
        }
        const cssOf = name => {
            const s = String(name || '').toLowerCase(); if (!s || s === 'none') return { w: 0, sty: 'none' };
            if (s.includes('double')) return { w: 3, sty: 'double' };
            if (s.includes('mediumdashdotdot') || s.includes('mediumdashdot') || s.includes('mediumdashed')) return { w: 2, sty: 'dashed' };
            if (s.includes('dashdotdot') || s.includes('dashdot') || s.includes('dashed')) return { w: 1, sty: 'dashed' };
            if (s.includes('dotted') || s.includes('hair')) return { w: 1, sty: 'dotted' };
            if (s.includes('thick')) return { w: 3, sty: 'solid' };
            if (s.includes('medium')) return { w: 2, sty: 'solid' };
            return { w: 1, sty: 'solid' };
        };
        const color = '#000';
        if (st.border) {
            const L = cssOf(st.border.l), R = cssOf(st.border.r), T = cssOf(st.border.t), B = cssOf(st.border.b);
            td.style.borderLeft   = L.w ? `${L.w}px ${L.sty} ${color}` : 'none';
            td.style.borderRight  = R.w ? `${R.w}px ${R.sty} ${color}` : 'none';
            td.style.borderTop    = T.w ? `${T.w}px ${T.sty} ${color}` : 'none';
            td.style.borderBottom = B.w ? `${B.w}px ${B.sty} ${color}` : 'none';
        }
    }

    /* ===== 가로 스크롤 동기화(컨테이너 내부 sticky) ===== */
    function updateScrollSyncFromDom() {
        const sc = document.getElementById('doc-scroll');
        const xbar = document.getElementById('xbar');
        const rail = xbar.querySelector('.rail');
        const tblEl = document.querySelector('#xhost table');

        // 테이블 폭 및 실효 콘텐츠 폭
        const tblW = Math.max(1,
            Math.ceil(tblEl?.getBoundingClientRect().width || 0),
            (tblEl?.scrollWidth || 0)
        );
        const effW = measureEffectiveContentWidth(tblEl);
        const contentW = Math.max(1, effW || tblW);

        // 레일 리사이즈
        rail.style.width = contentW + 'px';

        // 보조바 표시 여부 및 컨테이너 padding-bottom 예약
        const viewW = (sc.clientWidth | 0);
        const showBar = contentW > viewW;
        xbar.style.display = showBar ? 'block' : 'none';
        xbar.style.borderTop = showBar ? '1px solid #e9ecef' : 'none';
        sc.style.paddingBottom = showBar ? (xbar.offsetHeight + 2) + 'px' : '0px';

        // 동기 변환식 갱신
        const docMax = Math.max(0, contentW - viewW);
        const barMax = Math.max(0, (rail.scrollWidth | 0) - (xbar.clientWidth | 0));
        const clamp = (v, max) => (v < 0 ? 0 : (v > max ? max : v));
        const toDoc = (barX) => docMax ? Math.round((barX * docMax) / Math.max(1, barMax)) : 0;
        const toBar = (docX) => barMax ? Math.round((docX * barMax) / Math.max(1, docMax)) : 0;
        _sync = { docMax, barMax, toDoc, toBar };

        // 현재 값 보정 및 디버그 갱신
        sc.scrollLeft = clamp(sc.scrollLeft | 0, docMax);
        xbar.scrollLeft = clamp(toBar(sc.scrollLeft | 0), barMax);
        updateScrollDebug();
    }

    function clampBoth() {
        const sc = document.getElementById('doc-scroll');
        const xbar = document.getElementById('xbar');
        const clamp = (v, max) => (v < 0 ? 0 : (v > max ? max : v));
        sc.scrollLeft = clamp(sc.scrollLeft | 0, _sync.docMax);
        xbar.scrollLeft = clamp(_sync.toBar(sc.scrollLeft | 0), _sync.barMax);
        updateScrollDebug();
    }

    /* ===== 오토플로우 (기존 유지) ===== */
    function buildAutoFlowGroups(inputs) {
        const byPrefixCol = new Map();
        (inputs || []).forEach(f => {
            if (!f?.key || !f?.a1) return;
            const type = String(f.type || 'Text').toLowerCase(); if (type !== 'text') return;
            const m = String(f.key).match(/^(.*)_(\d+)$/); const rc = a1ToRC(f.a1); if (!rc) return;
            const sig = m ? `${m[1]}:${rc.c}` : `${f.key}:${rc.c}`;
            if (!byPrefixCol.has(sig)) byPrefixCol.set(sig, []);
            byPrefixCol.get(sig).push({ key: f.key, rc });
        });
        const groups = []; byPrefixCol.forEach(list => { list.sort((a, b) => a.rc.r - b.rc.r); groups.push({ keys: list.map(x => x.key) }); });
        return groups;
    }
    const cellDivByKey = key => document.querySelector(`#xhost td[data-key="${CSS.escape(key)}"] .cellc`);
    const tdByKey   = key => document.querySelector(`#xhost td[data-key="${CSS.escape(key)}"]`);
    function blockRectOfKeys(keys) {
        const tds = keys.map(tdByKey).filter(Boolean); if (!tds.length) return null;
        const host = document.getElementById('xhost').getBoundingClientRect();
        let l = Infinity, t = Infinity, r = -Infinity, b = -Infinity;
        for (const td of tds) { const rc = td.getBoundingClientRect(); l = Math.min(l, rc.left); t = Math.min(t, rc.top); r = Math.max(r, rc.right); b = Math.max(b, rc.bottom); }
        return { left: (l - host.left), top: (t - host.top), width: (r - l), height: (b - t) };
    }
    function clampToTable(r) {
        const tbl = document.querySelector('#xhost table'); if (!tbl) return r;
        const w = Math.ceil(tbl.getBoundingClientRect().width);
        const left = Math.max(0, Math.min(r.left, w));
        const right = Math.max(left, Math.min(r.left + r.width, w));
        return { left, top: r.top, width: (right - left), height: r.height };
    }
    function copyStyleFromFirstCell(el, firstCell) {
        const td = firstCell.closest('td'); const cs = getComputedStyle(firstCell);
        const rowPx = parseFloat(td?.dataset.rowpx || cs.lineHeight) || 16;
        el.style.lineHeight = rowPx + 'px';
        el.style.fontFamily = cs.fontFamily; el.style.fontSize = cs.fontSize; el.style.fontWeight = cs.fontWeight; el.style.fontStyle = cs.fontStyle;
        el.style.letterSpacing = cs.letterSpacing; el.style.wordSpacing = cs.wordSpacing; el.style.textAlign = cs.textAlign;
        el.style.paddingTop = '0px'; el.style.paddingBottom = '0px'; el.style.paddingLeft = cs.paddingLeft; el.style.paddingRight = cs.paddingRight;
    }
    let blocks = [];
    function createSingleBlocks() {
        const groups = buildAutoFlowGroups(Array.isArray(descriptor?.inputs) ? descriptor.inputs : []);
        const host = document.getElementById('xhost');
        blocks.forEach(b => b.el.remove()); blocks = [];
        for (const g of groups) {
            const keys = g.keys.filter(k => !!tdByKey(k)); if (!keys.length) continue;
            const lines = keys.map(k => (cellDivByKey(k)?.textContent || '')); keys.forEach(k => { const c = cellDivByKey(k); if (c) c.textContent = ''; });
            const block = document.createElement('div'); block.className = 'eb-block'; block.setAttribute('contenteditable', 'true'); block.textContent = lines.join('\n');
            const firstCell = cellDivByKey(keys[0]); if (!firstCell) continue; copyStyleFromFirstCell(block, firstCell);
            let r = blockRectOfKeys(keys); if (!r) continue; r = clampToTable(r);
            block.style.left = Math.round(r.left) + 'px'; block.style.top = Math.round(r.top) + 'px'; block.style.width = r.width + 'px'; block.style.height = r.height + 'px';
            const maxLines = keys.length;
            const placeCaretEnd = el => { try { const s = window.getSelection(); const rr = document.createRange(); rr.selectNodeContents(el); rr.collapse(false); s.removeAllRanges(); s.addRange(rr); } catch { } }
            const countLines = text => (String(text ?? '').match(/\n/g) || []).length + 1;
            const clampAndSave = () => {
                let v = String(block.textContent || '').replace(/\r\n?/g, '\n'); let arr = v.split('\n');
                if (arr.length > maxLines) { arr = arr.slice(0, maxLines); block.textContent = arr.join('\n'); placeCaretEnd(block); }
                if (arr.length < maxLines) { arr = arr.concat(Array(maxLines - arr.length).fill('')); block.textContent = arr.join('\n'); placeCaretEnd(block); }
                for (let i = 0; i < maxLines; i++) payloadInputs[keys[i]] = (arr[i] ?? '');
            };
            block.addEventListener('beforeinput', e => { if (e.inputType === 'insertParagraph') { const cur = (block.innerText || '').replace(/\r\n?/g, '\n').split('\n').length; if (cur >= maxLines) e.preventDefault(); } });
            block.addEventListener('keydown', e => {
                if (e.key === 'Enter') {
                    const cur = countLines((block.textContent || '').replace(/\r\n?/g, '\n')); if (cur >= maxLines) { e.preventDefault(); return; }
                    e.preventDefault(); document.execCommand('insertText', false, '\n'); clampAndSave();
                }
            });
            block.addEventListener('input', clampAndSave);
            block.addEventListener('paste', e => { e.preventDefault(); const text = (e.clipboardData || window.clipboardData).getData('text').replace(/\r\n?/g, '\n'); document.execCommand('insertText', false, text); });
            clampAndSave(); host.appendChild(block); blocks.push({ el: block, keys, maxLines });
        }
    }

    function toIsoDateOrEmpty(text) {
        if (!text) return ''; const s = String(text).trim(); let m = s.match(/^(\d{4})[./-](\d{1,2})[./-](\d{1,2})/);
        if (m) return `${m[1]}-${m[2].padStart(2, '0')}-${m[3].padStart(2, '0')}`; return '';
    }

    /* 실행 */
    const host = document.getElementById('doc-scroll');
    escapeFixedTraps(host);
    placeScrollHost();
    window.addEventListener('load', placeScrollHost);
    window.addEventListener('resize', () => { placeScrollHost(); updateScrollSyncFromDom(); });
    window.addEventListener('scroll', () => { lockRootScroll(); });

    const mo = new MutationObserver(() => { placeScrollHost(); updateScrollSyncFromDom(); });
    mo.observe(document.body, { attributes: true, childList: true, subtree: true });

    try { mount('#xlPreview', preview); } catch (e) { console.error(e); err('DOC_Err_PreviewFailed'); }

    // 스크롤 동기화 핸들러
    document.getElementById('xbar')?.addEventListener('scroll', () => {
        const sc = document.getElementById('doc-scroll'); const xbar = document.getElementById('xbar');
        const clamp = (v, max) => (v < 0 ? 0 : (v > max ? max : v));
        const nx = clamp(_sync.toDoc(xbar.scrollLeft | 0), _sync.docMax);
        if (nx !== sc.scrollLeft) sc.scrollLeft = nx;
        updateScrollDebug();
    });
    document.getElementById('doc-scroll')?.addEventListener('scroll', () => {
        const sc = document.getElementById('doc-scroll'); const xbar = document.getElementById('xbar');
        const clamp = (v, max) => (v < 0 ? 0 : (v > max ? max : v));
        const nx = clamp(_sync.toBar(sc.scrollLeft | 0), _sync.barMax);
        if (nx !== xbar.scrollLeft) xbar.scrollLeft = nx;
        updateScrollDebug();
    });

    // 저장/취소
    document.getElementById('btn-save')?.addEventListener('click', async () => {
        document.querySelectorAll('#xhost td[data-key]').forEach(td => {
            const key = td.getAttribute('data-key'); if (!key) return;
            if (key in payloadInputs) return;
            const di = td.querySelector('input[type="date"]'); if (di) payloadInputs[key] = di.value || '';
        });
        const form = document.getElementById('doc-form');
        const tpl = form.querySelector('input[name=TemplateCode]')?.value || '';
        const body = { templateCode: tpl, inputs: payloadInputs, approvals: {}, descriptorVersion: descriptor?.version || null };
        try {
            const ok = await EBCSRF.json(form.getAttribute('action') || '/Doc/Create', body, 'POST');
            if (ok?.redirectUrl) location.href = ok.redirectUrl; else info('DOC_Msg_Saved');
        } catch (e) { err('DOC_Err_SaveFailed'); }
    });
    document.getElementById('btn-cancel')?.addEventListener('click', () => { history.length > 1 ? history.back() : location.href = '/Doc/New' });
})();
</script>
}
