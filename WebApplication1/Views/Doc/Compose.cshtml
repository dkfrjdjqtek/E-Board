@* 2025.11.20 Changed: Compose 스크롤 컨테이너 위치를 Board와 동일 CSS 변수(--header-h,--footer-h,--sidebar-w) 기준으로 고정하고
   placeContainer() 인라인 스타일을 덮기 위해 top/right/bottom/left 에 !important 적용 (세로 스크롤바가 헤더/푸터 사이에만 표시되도록 정렬) *@
@model WebApplication1.Models.DocTLViewModel
@inject Microsoft.Extensions.Localization.IStringLocalizer<SharedResource> S
@{
    ViewData["Title"] = S["DOC_Title_Compose"];
    var templateCode = (string?)ViewBag.TemplateCode
                        ?? (Context?.Request?.Query["templateCode"].ToString() ?? string.Empty);
    var templateTitle = (string?)ViewBag.TemplateTitle ?? string.Empty;
    var descJson = (string?)ViewBag.DescriptorJson ?? "{}";
    var previewJson = (string?)ViewBag.PreviewJson ?? "{}";
}
<style>
    /* === 전역: 브라우저 기본 스크롤은 막고, 작업 영역(#doc-scroll)만 스크롤 허용 === */
    html,
    body {
        height: 100%;
        overflow: hidden !important;
        background: #fff;
        margin: 0;
    }

    /* === 작업 영역 컨테이너
           - Board 와 동일하게 레이아웃 CSS 변수(--header-h, --footer-h, --sidebar-w)를 기준으로 위치 고정
           - eb.doc.preview.common.js 의 placeContainer() 가 inline 으로 top/left/right/bottom 을 덮어써도
             아래 !important 로 항상 이 값이 우선하도록 처리
           - 이 컨테이너 하나만 세로 스크롤 담당, 가로 스크롤은 프리뷰 내부 컨테이너에서만 표시 === */
    #doc-scroll {
        position: fixed;
        top: var(--header-h, 56px) !important;
        right: 0 !important;
        bottom: var(--footer-h, 32px) !important;
        left: var(--sidebar-w, 270px) !important;

        box-sizing: border-box;
        padding: 16px 24px;
        background: #fff;

        overflow-y: auto;      /* 세로 스크롤 전용 (우측 벽에 붙음) */
        overflow-x: auto;    /* 가로 스크롤은 프리뷰 내부 컨테이너에서 처리 */
        overscroll-behavior: contain;
    }

    .page-header {
        display: flex;
        align-items: center;
        gap: 12px;
        padding: 16px;
        margin: 0;
    }

    .page-header h3 {
        margin: 0;
    }

    .form-actions {
        margin: 16px;
        padding: 12px 0;
        border-top: 1px solid #e9ecef;
        display: flex;
        gap: 8px;
        max-width: 100%;
    }

    .action-btn {
        width: 140px;
        height: 36px;
        white-space: nowrap;
    }

    /* 인쇄 시에는 전체 페이지가 자연스럽게 흐르도록 제한 해제 */
    @Html.Raw("@media print{#doc-scroll{overflow:visible;position:static;top:auto!important;right:auto!important;bottom:auto!important;left:auto!important;height:auto;padding:0}.form-actions{display:none}}")

    .btn {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        height: 36px;
        padding: 0 14px;
        border-radius: 8px;
        border: 1px solid transparent;
        cursor: pointer;
    }

    .btn-primary {
        background: #0d6efd;
        color: #fff;
    }

    .btn-outline-secondary {
        background: #fff;
        border-color: #cbd5e1;
        color: #111827;
    }
</style>

<div id="doc-scroll" data-template-code="@templateCode">
    <div class="page-header">
        <h3>@S["DOC_Title_Compose"]</h3>
        <span class="text-muted">@templateTitle</span>
    </div>

    <div id="doc-alert" class="mb-2" aria-live="polite"></div>

    <form id="doc-form" method="post" asp-controller="Doc" asp-action="Create" novalidate style="max-width:100%">
        @Html.AntiForgeryToken()
        <input type="hidden" name="TemplateCode" value="@templateCode" />
        <input type="hidden" name="templateCode" value="@templateCode" />

        <script type="application/json" id="DescriptorJson">@Html.Raw(descJson)</script>
        <script type="application/json" id="PreviewJson">@Html.Raw(previewJson)</script>

        <script>
            window.__RESX = @Html.Raw(System.Text.Json.JsonSerializer.Serialize(new {
                DOC_Err_PreviewFailed = S["DOC_Err_PreviewFailed"].Value,
                DOC_Err_SaveFailed = S["DOC_Err_SaveFailed"].Value,
                DOC_Msg_Saved = S["DOC_Msg_Saved"].Value,
                DOC_Val_TemplateRequired = S["DOC_Val_TemplateRequired"].Value,
                DOC_Btn_Cancel = S["DOC_Btn_Cancel"].Value,
                DOC_Submit_Button = S["DOC_Submit_Button"].Value
            }));
            // Compose 화면은 항상 쓰기 모드
            window.__DOC_IS_WRITE__ = true;
        </script>

        <div id="xlPreview">
            <div id="xhost"></div>
        </div>

        <div class="form-actions">
            <button type="button" id="btn-save" class="btn btn-primary action-btn" data-doc-submit>
                @S["DOC_Submit_Button"]
            </button>
            <button type="button" id="btn-cancel" class="btn btn-outline-secondary action-btn">
                @S["DOC_Btn_Cancel"]
            </button>
        </div>
    </form>
</div>

@section Styles {
    <link rel="stylesheet" href="~/css/eb.doc.preview.css" asp-append-version="true" />
}

@section Scripts {
    <script src="~/js/eb.csrf.js"></script>
    <script src="~/js/eb.doc.preview.common.js"></script>

    <script>
        (function () {
            function initPreview() {
                // 공통 프리뷰 스크립트가 initCompose를 제공하면 사용, 아니면 mount 직접 호출
                if (window.EBDocPreview?.initCompose) {
                    return window.EBDocPreview.initCompose();
                }

                try {
                    const raw = document.getElementById('PreviewJson')?.textContent || '{}';
                    const preview = JSON.parse(raw || '{}');
                    window.EBDocPreview?.mount('#xlPreview', preview, { isWrite: true });
                } catch (e) {
                    console.error('Compose preview init failed', e);
                    const host = document.getElementById('xhost');
                    if (host) {
                        const msg = (window.__RESX && window.__RESX.DOC_Err_PreviewFailed) || 'Preview error';
                        host.innerHTML = `<div class="alert alert-danger mb-0 py-1">${msg}</div>`;
                    }
                }
            }

            function resx(k, fallback) {
                return (window.__RESX && window.__RESX[k]) || fallback || k;
            }

            async function submitJson(action, payload, csrf) {
                return await fetch(action, {
                    method: 'POST',
                    credentials: 'same-origin',
                    headers: {
                        'Accept': 'application/json',
                        'Content-Type': 'application/json',
                        'RequestVerificationToken': csrf || ''
                    },
                    body: JSON.stringify(payload)
                });
            }

            async function submitFormFallback(action, payload, csrf) {
                const fd = new FormData();
                fd.append('templateCode', payload.templateCode || '');
                fd.append('inputsJson', JSON.stringify(payload.inputs || {}));
                if (csrf) fd.append('__RequestVerificationToken', csrf);
                return await fetch(action, {
                    method: 'POST',
                    credentials: 'same-origin',
                    body: fd
                });
            }

            function pickDocId(data) {
                return data?.docId || data?.id || data?.DocId || '';
            }

            async function handleSubmit() {
                const btn = document.getElementById('btn-save');
                const form = document.getElementById('doc-form');
                const action = form.getAttribute('action') || '/Doc/Create';
                const templateCode = document.querySelector('[name="templateCode"]')?.value || '';
                const csrf = document.querySelector('input[name="__RequestVerificationToken"]')?.value || '';
                const inputs = (window.EBDocPreview && window.EBDocPreview.payloadInputs)
                    ? window.EBDocPreview.payloadInputs
                    : {};

                if (!templateCode) {
                    alert(resx('DOC_Val_TemplateRequired', 'Template required'));
                    return;
                }

                btn.disabled = true;
                const old = btn.textContent;
                btn.textContent = '…';

                try {
                    // 1) JSON 우선 시도
                    let res = await submitJson(action, { templateCode, inputs }, csrf);

                    // JSON 미수용/CSRF 바인딩 실패 시 FormData 폴백
                    if (!res.ok && (res.status === 400 || res.status === 404 || res.status === 415 || res.status === 419)) {
                        res = await submitFormFallback(action, { templateCode, inputs }, csrf);
                    }

                    const ctype = res.headers.get('content-type') || '';
                    const data = ctype.includes('application/json')
                        ? await res.json().catch(() => ({}))
                        : { html: await res.text() };

                    if (!res.ok) {
                        const detail = (data && (data.message || data.error || data.html))
                            ? '\n' + (data.message || data.error || data.html).toString().slice(0, 500)
                            : '';
                        alert(resx('DOC_Err_SaveFailed', 'Save failed') + ` [${res.status}]` + detail);
                        return;
                    }

                    if (data.redirectUrl) {
                        location.href = data.redirectUrl;
                        return;
                    }

                    // ★ 세그먼트가 아닌 쿼리 문자열로 Detail 이동 (404 방지)
                    const docId = pickDocId(data);
                    if (docId) {
                        location.href = `/Doc/Detail?id=${encodeURIComponent(docId)}`;
                        return;
                    }

                    alert(resx('DOC_Msg_Saved', 'Saved'));
                } catch (e) {
                    console.error(e);
                    alert(resx('DOC_Err_SaveFailed', 'Save failed'));
                } finally {
                    btn.disabled = false;
                    btn.textContent = old;
                }
            }

            function wire() {
                initPreview();
                document.getElementById('btn-save')?.addEventListener('click', handleSubmit);
                document.getElementById('btn-cancel')?.addEventListener('click', () => history.back());
            }

            if (document.readyState === 'loading') {
                document.addEventListener('DOMContentLoaded', wire, { once: true });
            } else {
                wire();
            }
        })();
    </script>
}
